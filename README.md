# StAX-XML

[English](#english) | [ÌïúÍµ≠Ïñ¥](#korean)

---

## English

A high-performance, pull-based XML parser for JavaScript/TypeScript inspired by Java's StAX (Streaming API for XML). Unlike traditional XML-to-JSON mappers, StAX-XML allows you to map XML data to any custom structure you desire while efficiently handling large XML files.

### üöÄ Features

- **Pull-based Parsing**: Stream-based approach for memory-efficient processing of large XML files
- **Custom Mapping**: Map XML data to any structure you want, not just plain JSON objects
- **High Performance**: Optimized for speed and low memory usage
- **Universal Compatibility**: Works in Node.js, Bun, Deno, and web browsers using only Web Standard APIs
- **Namespace Support**: Basic XML namespace handling
- **Entity Support**: Built-in entity decoding with custom entity support
- **TypeScript Ready**: Full TypeScript support with comprehensive type definitions

### üì¶ Installation

```bash
# npm
npm install stax-xml
# yarn
yarn add stax-xml
# pnpm
pnpm add stax-xml
# bun
bun add stax-xml
# deno
deno add npm:stax-xml
```

### üîß Quick Start

#### Parsing XML String

```typescript
import { StaxXmlParser, XmlEventType } from 'stax-xml';

// Create a ReadableStream from XML string
const xmlContent = `
  <books>
    <book id="1">
      <title>The Great Gatsby</title>
      <author>F. Scott Fitzgerald</author>
    </book>
    <book id="2">
      <title>To Kill a Mockingbird</title>
      <author>Harper Lee</author>
    </book>
  </books>
`;

const stream = new ReadableStream({
  start(controller) {
    controller.enqueue(new TextEncoder().encode(xmlContent));
    controller.close();
  }
});

// Parse XML with pull-based approach
const parser = new StaxXmlParser(stream);
const books = [];
let currentBook = null;
let currentText = '';

for await (const event of parser) {
  switch (event.type) {
    case XmlEventType.START_ELEMENT:
      if (event.name === 'book') {
        currentBook = { id: event.attributes?.id || '', title: '', author: '' };
      }
      currentText = '';
      break;
      
    case XmlEventType.CHARACTERS:
      currentText += event.data;
      break;
      
    case XmlEventType.END_ELEMENT:
      if (currentBook) {
        if (event.name === 'title') {
          currentBook.title = currentText.trim();
        } else if (event.name === 'author') {
          currentBook.author = currentText.trim();
        } else if (event.name === 'book') {
          books.push(currentBook);
          currentBook = null;
        }
      }
      break;
  }
}

console.log(books);
// Output: [
//   { id: "1", title: "The Great Gatsby", author: "F. Scott Fitzgerald" },
//   { id: "2", title: "To Kill a Mockingbird", author: "Harper Lee" }
// ]
```

#### Parsing Remote XML with Fetch

```typescript
import { StaxXmlParser, XmlEventType } from 'stax-xml';

async function parseRemoteXml(url: string) {
  try {
    // Fetch XML from remote URL
    const response = await fetch(url);
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    // Get the response body as a ReadableStream
    const xmlStream = response.body;
    
    if (!xmlStream) {
      throw new Error('No response body');
    }
    
    // Parse the XML stream directly
    const parser = new StaxXmlParser(xmlStream);
    const results = [];
    let currentItem = {};
    let currentText = '';
    
    for await (const event of parser) {
      switch (event.type) {
        case XmlEventType.START_ELEMENT:
          if (event.name === 'item') {
            currentItem = {};
          }
          currentText = '';
          break;
          
        case XmlEventType.CHARACTERS:
          currentText += event.data;
          break;
          
        case XmlEventType.END_ELEMENT:
          if (event.name === 'title' || event.name === 'description') {
            currentItem[event.name] = currentText.trim();
          } else if (event.name === 'item') {
            results.push(currentItem);
          }
          break;
      }
    }
    
    return results;
  } catch (error) {
    console.error('Error parsing remote XML:', error);
    throw error;
  }
}

// Usage examples
const rssUrl = 'https://example.com/feed.xml';
const xmlApiUrl = 'https://api.example.com/data.xml';

// Parse RSS feed
parseRemoteXml(rssUrl)
  .then(items => {
    console.log('RSS items:', items);
  })
  .catch(error => {
    console.error('Failed to parse RSS:', error);
  });

// Parse API response
parseRemoteXml(xmlApiUrl)
  .then(data => {
    console.log('API data:', data);
  })
  .catch(error => {
    console.error('Failed to parse API response:', error);
  });
```

### üåê Platform Compatibility

StAX-XML uses only Web Standard APIs, making it compatible with:

- **Node.js** (v18+)
- **Bun** (any version)
- **Deno** (any version)
- **Web Browsers** (modern browsers)
- **Edge Runtime** (Vercel, Cloudflare Workers, etc.)

### ‚ö° Advanced Usage

#### StaxXmlWriter - Creating XML Documents

StAX-XML also includes a powerful XML writer that allows you to generate XML documents programmatically.

##### Writing to Local File

```typescript
import { StaxXmlWriter } from 'stax-xml';
import { createWriteStream } from 'fs';

// For Node.js - create a WritableStream from fs
async function createLocalXmlFile() {
  const fileStream = createWriteStream('./output.xml');
  
  // Convert Node.js WriteStream to Web Standard WritableStream
  const writableStream = new WritableStream<Uint8Array>({
    write(chunk) {
      fileStream.write(chunk);
    },
    close() {
      fileStream.end();
    }
  });

  const writer = new StaxXmlWriter(writableStream, {
    prettyPrint: true,
    indentString: '  '
  });

  // Write XML document
  writer.writeStartDocument('1.0', 'utf-8');
  
  writer.writeStartElement('catalog', undefined, undefined, { version: '1.0' });
  
  writer.writeStartElement('product', undefined, undefined, { id: '001' });
  
  writer.writeStartElement('name');
  writer.writeCharacters('Laptop Computer');
  writer.writeEndElement();
  
  writer.writeStartElement('price', undefined, undefined, { currency: 'USD' });
  writer.writeCharacters('999.99');
  writer.writeEndElement();
  
  writer.writeEndElement(); // product
  writer.writeEndElement(); // catalog
  
  await writer.writeEndDocument();
  console.log('XML file created successfully!');
}

createLocalXmlFile();
```

##### Express.js Middleware - XML Response

```typescript
import express from 'express';
import { StaxXmlWriter } from 'stax-xml';

const app = express();

// Middleware to create XML response
app.get('/api/users', async (req, res) => {
  try {
    // Sample data
    const users = [
      { id: 1, name: 'John Doe', email: 'john@example.com' },
      { id: 2, name: 'Jane Smith', email: 'jane@example.com' }
    ];

    // Create a WritableStream that writes to Express response
    const writableStream = new WritableStream<Uint8Array>({
      write(chunk) {
        res.write(chunk);
      },
      close() {
        res.end();
      }
    });

    const writer = new StaxXmlWriter(writableStream, {
      prettyPrint: true,
      indentString: '  '
    });

    // Set appropriate headers
    res.setHeader('Content-Type', 'application/xml; charset=utf-8');
    res.setHeader('Cache-Control', 'no-cache');

    // Write XML
    writer.writeStartDocument('1.0', 'utf-8');
    writer.writeStartElement('users');
    
    for (const user of users) {
      writer.writeStartElement('user', undefined, undefined, { id: user.id.toString() });
      
      writer.writeStartElement('name');
      writer.writeCharacters(user.name);
      writer.writeEndElement();
      
      writer.writeStartElement('email');
      writer.writeCharacters(user.email);
      writer.writeEndElement();
      
      writer.writeEndElement(); // user
    }
    
    writer.writeEndElement(); // users
    await writer.writeEndDocument();
    
  } catch (error) {
    res.status(500).json({ error: 'Failed to generate XML' });
  }
});

app.listen(3000, () => {
  console.log('Server running on port 3000');
});
```

##### Hono Framework - Streaming XML Response

```typescript
import { Hono } from 'hono';
import { StaxXmlWriter } from 'stax-xml';

const app = new Hono();

app.get('/api/products', async (c) => {
  // Sample product data
  const products = [
    { id: 'P001', name: 'Smartphone', price: 699.99, category: 'Electronics' },
    { id: 'P002', name: 'Headphones', price: 199.99, category: 'Electronics' },
    { id: 'P003', name: 'Coffee Maker', price: 149.99, category: 'Appliances' }
  ];

  // Create ReadableStream for streaming response
  const readable = new ReadableStream<Uint8Array>({
    async start(controller) {
      // Create a WritableStream that enqueues data to the controller
      const writableStream = new WritableStream<Uint8Array>({
        write(chunk) {
          controller.enqueue(chunk);
        },
        close() {
          controller.close();
        },
        abort(reason) {
          controller.error(reason);
        }
      });

      const writer = new StaxXmlWriter(writableStream, {
        prettyPrint: true,
        indentString: '    '
      });

      try {
        // Generate XML
        writer.writeStartDocument('1.0', 'utf-8');
        writer.writeStartElement('products', undefined, undefined, {
          count: products.length.toString(),
          generated: new Date().toISOString()
        });
        
        for (const product of products) {
          writer.writeStartElement('product', undefined, undefined, {
            id: product.id,
            category: product.category
          });
          
          writer.writeStartElement('name');
          writer.writeCharacters(product.name);
          writer.writeEndElement();
          
          writer.writeStartElement('price', undefined, undefined, { currency: 'USD' });
          writer.writeCharacters(product.price.toString());
          writer.writeEndElement();
          
          writer.writeEndElement(); // product
        }
        
        writer.writeEndElement(); // products
        await writer.writeEndDocument();
        
      } catch (error) {
        controller.error(error);
      }
    }
  });

  return new Response(readable, {
    headers: {
      'Content-Type': 'application/xml; charset=utf-8',
      'Cache-Control': 'no-cache',
      'Transfer-Encoding': 'chunked'
    }
  });
});

export default app;
```

##### Advanced Writer Features

```typescript
import { StaxXmlWriter } from 'stax-xml';

// Create in-memory XML with custom entities and namespaces
async function createAdvancedXml() {
  let xmlOutput = '';
  
  const writableStream = new WritableStream<Uint8Array>({
    write(chunk) {
      xmlOutput += new TextDecoder().decode(chunk);
    }
  });

  const writer = new StaxXmlWriter(writableStream, {
    prettyPrint: true,
    indentString: '  ',
    addEntities: [
      { entity: 'company', value: 'Acme Corporation' },
      { entity: 'copyright', value: '¬© 2024' }
    ],
    autoEncodeEntities: true
  });

  // Write XML with namespaces and custom entities
  writer.writeStartDocument('1.0', 'utf-8');
  
  writer.writeStartElement('document', 'doc', 'http://example.com/document', { version: '2.0' });
  writer.writeNamespace('meta', 'http://example.com/metadata');
  
  writer.writeStartElement('header', 'meta');
  writer.writeStartElement('title');
  writer.writeCharacters('Product Catalog');
  writer.writeEndElement();
  
  writer.writeStartElement('company');
  writer.writeCharacters('&company;'); // Will be encoded automatically
  writer.writeEndElement();
  writer.writeEndElement(); // header
  
  writer.writeStartElement('content');
  writer.writeStartElement('item', undefined, undefined, { type: 'featured' });
  
  // Self-closing element
  writer.writeStartElement('thumbnail', undefined, undefined, {
    src: 'image.jpg',
    alt: 'Product Image'
  });
  writer.writeEndElementSelfClosing();
  
  writer.writeStartElement('description');
  writer.writeCDATA('<p>This is <b>HTML</b> content in CDATA</p>');
  writer.writeEndElement();
  
  writer.writeEndElement(); // item
  writer.writeEndElement(); // content
  writer.writeEndElement(); // document
  
  await writer.writeEndDocument();
  
  return xmlOutput;
}

// Usage
createAdvancedXml().then(xml => {
  console.log('Generated XML:', xml);
});
```

#### Custom Entity Support

```typescript
const parser = new StaxXmlParser(stream, {
  addEntities: [
    { entity: 'custom', value: 'Custom Value' },
    { entity: 'special', value: '‚òÖ' }
  ]
});
```

#### Large File Processing

```typescript
// Efficient processing of large XML files
const parser = new StaxXmlParser(largeXmlStream, {
  maxBufferSize: 128 * 1024, // 128KB buffer
  enableBufferCompaction: true
});

// Process events as they come, without loading entire file into memory
for await (const event of parser) {
  // Handle each event individually
  processEvent(event);
}
```

#### Namespace Handling

```typescript
// XML with namespaces
const xmlWithNamespaces = `
  <root xmlns:ns="http://example.com/namespace">
    <ns:element>Content</ns:element>
  </root>
`;

for await (const event of parser) {
  if (event.type === XmlEventType.START_ELEMENT) {
    console.log('Element:', event.name);
    console.log('Local name:', event.localName);
    console.log('Namespace URI:', event.uri);
    console.log('Prefix:', event.prefix);
  }
}
```

### üéØ Event Types

- `START_DOCUMENT`: Beginning of XML document
- `END_DOCUMENT`: End of XML document
- `START_ELEMENT`: Opening XML tag
- `END_ELEMENT`: Closing XML tag
- `CHARACTERS`: Text content between tags
- `CDATA`: CDATA section content
- `ERROR`: Parse error occurred

### üìö API Reference

#### StaxXmlParser

```typescript
class StaxXmlParser {
  constructor(
    xmlStream: ReadableStream<Uint8Array>,
    options?: StaxXmlParserOptions
  )
}

interface StaxXmlParserOptions {
  encoding?: string; // Default: 'utf-8'
  addEntities?: { entity: string, value: string }[];
  autoDecodeEntities?: boolean; // Default: true
  maxBufferSize?: number; // Default: 64KB
  enableBufferCompaction?: boolean; // Default: true
}
```

#### StaxXmlWriter

```typescript
class StaxXmlWriter {
  constructor(
    outputStream: WritableStream<Uint8Array>,
    options?: StaxXmlWriterOptions
  )

  // Document Level Methods
  writeStartDocument(version?: string, encoding?: string): this
  writeEndDocument(): Promise<void>

  // Element Writing Methods
  writeStartElement(localName: string, prefix?: string, uri?: string, 
                   attributes?: { [key: string]: string }): this
  writeEndElement(): this
  writeEndElementSelfClosing(): this
  writeEmptyElement(localName: string, prefix?: string, uri?: string, 
                   attributes?: XmlAttribute[], namespaces?: NamespaceDeclaration[]): this

  // Attribute and Namespace Methods
  writeAttribute(localName: string, value: string, prefix?: string, uri?: string): this
  writeNamespace(prefix: string, uri: string): this

  // Content Writing Methods
  writeCharacters(text: string): this
  writeCDATA(cdata: string): this
  writeComment(comment: string): this
  writeProcessingInstruction(target: string, data?: string): this

  // Utility Methods
  setPrettyPrint(enabled: boolean): this
  setIndentString(indentString: string): this
  isPrettyPrintEnabled(): boolean
  getIndentString(): string
}

interface StaxXmlWriterOptions {
  encoding?: string; // Default: 'utf-8'
  prettyPrint?: boolean; // Default: false
  indentString?: string; // Default: '  '
  addEntities?: { entity: string, value: string }[];
  autoEncodeEntities?: boolean; // Default: true
  namespaces?: NamespaceDeclaration[];
}

interface XmlAttribute {
  localName: string;
  value: string;
  prefix?: string;
  uri?: string;
}

interface NamespaceDeclaration {
  prefix?: string;
  uri: string;
}
```

### üß™ Testing

```bash
bun test
```

### üìÑ License

MIT

### ü§ù Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

---

## Korean

JavaÏùò StAX(Streaming API for XML)ÏóêÏÑú ÏòÅÍ∞êÏùÑ Î∞õÏùÄ Í≥†ÏÑ±Îä• pull Î∞©ÏãùÏùò JavaScript/TypeScript XML ÌååÏÑúÏûÖÎãàÎã§. Í∏∞Ï°¥Ïùò XML-JSON Îß§ÌçºÏôÄ Îã¨Î¶¨, StAX-XMLÏùÑ ÏÇ¨Ïö©ÌïòÎ©¥ XML Îç∞Ïù¥ÌÑ∞Î•º ÏõêÌïòÎäî ÏûÑÏùòÏùò Íµ¨Ï°∞Î°ú Îß§ÌïëÌï† Ïàò ÏûàÏúºÎ©∞, ÌÅ∞ XML ÌååÏùºÎèÑ Ìö®Ïú®Ï†ÅÏúºÎ°ú Ï≤òÎ¶¨Ìï† Ïàò ÏûàÏäµÎãàÎã§.

### üöÄ Ï£ºÏöî Í∏∞Îä•

- **Pull Î∞©Ïãù ÌååÏã±**: ÎåÄÏö©Îüâ XML ÌååÏùºÏùò Î©îÎ™®Î¶¨ Ìö®Ïú®Ï†Å Ï≤òÎ¶¨Î•º ÏúÑÌïú Ïä§Ìä∏Î¶º Í∏∞Î∞ò Ï†ëÍ∑º
- **ÏÇ¨Ïö©Ïûê Ï†ïÏùò Îß§Ìïë**: Îã®ÏàúÌïú JSON Í∞ùÏ≤¥Í∞Ä ÏïÑÎãå ÏõêÌïòÎäî Íµ¨Ï°∞Î°ú XML Îç∞Ïù¥ÌÑ∞ Îß§Ìïë Í∞ÄÎä•
- **Í≥†ÏÑ±Îä•**: ÏÜçÎèÑÏôÄ ÎÇÆÏùÄ Î©îÎ™®Î¶¨ ÏÇ¨Ïö©ÎüâÏóê ÏµúÏ†ÅÌôî
- **Î≤îÏö© Ìò∏ÌôòÏÑ±**: Ïõπ ÌëúÏ§Ä APIÎßå ÏÇ¨Ïö©ÌïòÏó¨ Node.js, Bun, Deno, Ïõπ Î∏åÎùºÏö∞Ï†ÄÏóêÏÑú Î™®Îëê ÎèôÏûë
- **ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ ÏßÄÏõê**: Í∏∞Î≥∏Ï†ÅÏù∏ XML ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ Ï≤òÎ¶¨
- **ÏóîÌã∞Ìã∞ ÏßÄÏõê**: ÎÇ¥Ïû• ÏóîÌã∞Ìã∞ ÎîîÏΩîÎî© Î∞è ÏÇ¨Ïö©Ïûê Ï†ïÏùò ÏóîÌã∞Ìã∞ ÏßÄÏõê
- **TypeScript ÏßÄÏõê**: Ìè¨Í¥ÑÏ†ÅÏù∏ ÌÉÄÏûÖ Ï†ïÏùòÎ°ú ÏôÑÏ†ÑÌïú TypeScript ÏßÄÏõê

### üì¶ ÏÑ§Ïπò

```bash
# npm
npm install stax-xml
# yarn
yarn add stax-xml
# pnpm
pnpm add stax-xml
# bun
bun add stax-xml
# deno
deno add npm:stax-xml
```

### üîß Îπ†Î•∏ ÏãúÏûë

#### XML Î¨∏ÏûêÏó¥ ÌååÏã±

```typescript
import { StaxXmlParser, XmlEventType } from 'stax-xml';

// XML Î¨∏ÏûêÏó¥Î°úÎ∂ÄÌÑ∞ ReadableStream ÏÉùÏÑ±
const xmlContent = `
  <books>
    <book id="1">
      <title>ÏúÑÎåÄÌïú Í∞úÏ∏†ÎπÑ</title>
      <author>F. Ïä§ÏΩß ÌîºÏ∏†Ï†úÎü¥Îìú</author>
    </book>
    <book id="2">
      <title>ÏïµÎ¨¥ÏÉà Ï£ΩÏù¥Í∏∞</title>
      <author>ÌïòÌçº Î¶¨</author>
    </book>
  </books>
`;

const stream = new ReadableStream({
  start(controller) {
    controller.enqueue(new TextEncoder().encode(xmlContent));
    controller.close();
  }
});

// Pull Î∞©ÏãùÏúºÎ°ú XML ÌååÏã±
const parser = new StaxXmlParser(stream);
const books = [];
let currentBook = null;
let currentText = '';

for await (const event of parser) {
  switch (event.type) {
    case XmlEventType.START_ELEMENT:
      if (event.name === 'book') {
        currentBook = { id: event.attributes?.id || '', title: '', author: '' };
      }
      currentText = '';
      break;
      
    case XmlEventType.CHARACTERS:
      currentText += event.data;
      break;
      
    case XmlEventType.END_ELEMENT:
      if (currentBook) {
        if (event.name === 'title') {
          currentBook.title = currentText.trim();
        } else if (event.name === 'author') {
          currentBook.author = currentText.trim();
        } else if (event.name === 'book') {
          books.push(currentBook);
          currentBook = null;
        }
      }
      break;
  }
}

console.log(books);
// Ï∂úÎ†•: [
//   { id: "1", title: "ÏúÑÎåÄÌïú Í∞úÏ∏†ÎπÑ", author: "F. Ïä§ÏΩß ÌîºÏ∏†Ï†úÎü¥Îìú" },
//   { id: "2", title: "ÏïµÎ¨¥ÏÉà Ï£ΩÏù¥Í∏∞", author: "ÌïòÌçº Î¶¨" }
// ]
```

#### FetchÎ°ú ÏõêÍ≤© XML ÌååÏã±

```typescript
import { StaxXmlParser, XmlEventType } from 'stax-xml';

async function parseRemoteXml(url: string) {
  try {
    // ÏõêÍ≤© URLÏóêÏÑú XML Í∞ÄÏ†∏Ïò§Í∏∞
    const response = await fetch(url);
    
    if (!response.ok) {
      throw new Error(`HTTP Ïò§Î•ò! ÏÉÅÌÉú: ${response.status}`);
    }
    
    // ÏùëÎãµ Î≥∏Î¨∏ÏùÑ ReadableStreamÏúºÎ°ú Í∞ÄÏ†∏Ïò§Í∏∞
    const xmlStream = response.body;
    
    if (!xmlStream) {
      throw new Error('ÏùëÎãµ Î≥∏Î¨∏Ïù¥ ÏóÜÏäµÎãàÎã§');
    }
    
    // XML Ïä§Ìä∏Î¶ºÏùÑ ÏßÅÏ†ë ÌååÏã±
    const parser = new StaxXmlParser(xmlStream);
    const results = [];
    let currentItem = {};
    let currentText = '';
    
    for await (const event of parser) {
      switch (event.type) {
        case XmlEventType.START_ELEMENT:
          if (event.name === 'item') {
            currentItem = {};
          }
          currentText = '';
          break;
          
        case XmlEventType.CHARACTERS:
          currentText += event.data;
          break;
          
        case XmlEventType.END_ELEMENT:
          if (event.name === 'title' || event.name === 'description') {
            currentItem[event.name] = currentText.trim();
          } else if (event.name === 'item') {
            results.push(currentItem);
          }
          break;
      }
    }
    
    return results;
  } catch (error) {
    console.error('ÏõêÍ≤© XML ÌååÏã± Ïò§Î•ò:', error);
    throw error;
  }
}

// ÏÇ¨Ïö© ÏòàÏ†ú
const rssUrl = 'https://example.com/feed.xml';
const xmlApiUrl = 'https://api.example.com/data.xml';

// RSS ÌîºÎìú ÌååÏã±
parseRemoteXml(rssUrl)
  .then(items => {
    console.log('RSS Ìï≠Î™©:', items);
  })
  .catch(error => {
    console.error('RSS ÌååÏã± Ïã§Ìå®:', error);
  });

// API ÏùëÎãµ ÌååÏã±
parseRemoteXml(xmlApiUrl)
  .then(data => {
    console.log('API Îç∞Ïù¥ÌÑ∞:', data);
  })
  .catch(error => {
    console.error('API ÏùëÎãµ ÌååÏã± Ïã§Ìå®:', error);
  });
```

### üåê ÌîåÎû´Ìèº Ìò∏ÌôòÏÑ±

StAX-XMLÏùÄ Ïõπ ÌëúÏ§Ä APIÎßåÏùÑ ÏÇ¨Ïö©ÌïòÏó¨ Îã§Ïùå ÌôòÍ≤ΩÏóêÏÑú ÎèôÏûëÌï©ÎãàÎã§:

- **Node.js** (v18+)
- **Bun** (Î™®Îì† Î≤ÑÏ†Ñ)
- **Deno** (Î™®Îì† Î≤ÑÏ†Ñ)
- **Ïõπ Î∏åÎùºÏö∞Ï†Ä** (ÏµúÏã† Î∏åÎùºÏö∞Ï†Ä)
- **Edge Runtime** (Vercel, Cloudflare Workers Îì±)

### ‚ö° Í≥†Í∏â ÏÇ¨Ïö©Î≤ï

#### StaxXmlWriter - XML Î¨∏ÏÑú ÏÉùÏÑ±

StAX-XMLÏùÄ ÌîÑÎ°úÍ∑∏ÎûòÎ∞ç Î∞©ÏãùÏúºÎ°ú XML Î¨∏ÏÑúÎ•º ÏÉùÏÑ±Ìï† Ïàò ÏûàÎäî Í∞ïÎ†•Ìïú XML ÏûëÏÑ±Í∏∞ÎèÑ Ìè¨Ìï®ÌïòÍ≥† ÏûàÏäµÎãàÎã§.

##### Î°úÏª¨ ÌååÏùº ÏÉùÏÑ±

```typescript
import { StaxXmlWriter } from 'stax-xml';
import { createWriteStream } from 'fs';

// Node.jsÏö© - fsÏóêÏÑú WritableStream ÏÉùÏÑ±
async function createLocalXmlFile() {
  const fileStream = createWriteStream('./output.xml');
  
  // Node.js WriteStreamÏùÑ Ïõπ ÌëúÏ§Ä WritableStreamÏúºÎ°ú Î≥ÄÌôò
  const writableStream = new WritableStream<Uint8Array>({
    write(chunk) {
      fileStream.write(chunk);
    },
    close() {
      fileStream.end();
    }
  });

  const writer = new StaxXmlWriter(writableStream, {
    prettyPrint: true,
    indentString: '  '
  });

  // XML Î¨∏ÏÑú ÏûëÏÑ±
  writer.writeStartDocument('1.0', 'utf-8');
  
  writer.writeStartElement('catalog', undefined, undefined, { version: '1.0' });
  
  writer.writeStartElement('product', undefined, undefined, { id: '001' });
  
  writer.writeStartElement('name');
  writer.writeCharacters('ÎÖ∏Ìä∏Î∂Å Ïª¥Ìì®ÌÑ∞');
  writer.writeEndElement();
  
  writer.writeStartElement('price', undefined, undefined, { currency: 'KRW' });
  writer.writeCharacters('1299000');
  writer.writeEndElement();
  
  writer.writeEndElement(); // product
  writer.writeEndElement(); // catalog
  
  await writer.writeEndDocument();
  console.log('XML ÌååÏùºÏù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§!');
}

createLocalXmlFile();
```

##### Express.js ÎØ∏Îì§Ïõ®Ïñ¥ - XML ÏùëÎãµ

```typescript
import express from 'express';
import { StaxXmlWriter } from 'stax-xml';

const app = express();

// XML ÏùëÎãµÏùÑ ÏÉùÏÑ±ÌïòÎäî ÎØ∏Îì§Ïõ®Ïñ¥
app.get('/api/users', async (req, res) => {
  try {
    // ÏÉòÌîå Îç∞Ïù¥ÌÑ∞
    const users = [
      { id: 1, name: 'ÍπÄÏ≤†Ïàò', email: 'kim@example.com' },
      { id: 2, name: 'Ïù¥ÏòÅÌù¨', email: 'lee@example.com' }
    ];

    // Express ÏùëÎãµÏóê Ïì∞Îäî WritableStream ÏÉùÏÑ±
    const writableStream = new WritableStream<Uint8Array>({
      write(chunk) {
        res.write(chunk);
      },
      close() {
        res.end();
      }
    });

    const writer = new StaxXmlWriter(writableStream, {
      prettyPrint: true,
      indentString: '  '
    });

    // Ï†ÅÏ†àÌïú Ìó§Îçî ÏÑ§Ï†ï
    res.setHeader('Content-Type', 'application/xml; charset=utf-8');
    res.setHeader('Cache-Control', 'no-cache');

    // XML ÏûëÏÑ±
    writer.writeStartDocument('1.0', 'utf-8');
    writer.writeStartElement('users');
    
    for (const user of users) {
      writer.writeStartElement('user', undefined, undefined, { id: user.id.toString() });
      
      writer.writeStartElement('name');
      writer.writeCharacters(user.name);
      writer.writeEndElement();
      
      writer.writeStartElement('email');
      writer.writeCharacters(user.email);
      writer.writeEndElement();
      
      writer.writeEndElement(); // user
    }
    
    writer.writeEndElement(); // users
    await writer.writeEndDocument();
    
  } catch (error) {
    res.status(500).json({ error: 'XML ÏÉùÏÑ±Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§' });
  }
});

app.listen(3000, () => {
  console.log('ÏÑúÎ≤ÑÍ∞Ä Ìè¨Ìä∏ 3000ÏóêÏÑú Ïã§Ìñâ Ï§ëÏûÖÎãàÎã§');
});
```

##### Hono ÌîÑÎ†àÏûÑÏõåÌÅ¨ - Ïä§Ìä∏Î¶¨Î∞ç XML ÏùëÎãµ

```typescript
import { Hono } from 'hono';
import { StaxXmlWriter } from 'stax-xml';

const app = new Hono();

app.get('/api/products', async (c) => {
  // ÏÉòÌîå Ï†úÌíà Îç∞Ïù¥ÌÑ∞
  const products = [
    { id: 'P001', name: 'Ïä§ÎßàÌä∏Ìè∞', price: 899000, category: 'Ï†ÑÏûêÍ∏∞Í∏∞' },
    { id: 'P002', name: 'Ìó§ÎìúÌè∞', price: 259000, category: 'Ï†ÑÏûêÍ∏∞Í∏∞' },
    { id: 'P003', name: 'Ïª§ÌîºÎ©îÏù¥Ïª§', price: 189000, category: 'Í∞ÄÏ†ÑÏ†úÌíà' }
  ];

  // Ïä§Ìä∏Î¶¨Î∞ç ÏùëÎãµÏö© ReadableStream ÏÉùÏÑ±
  const readable = new ReadableStream<Uint8Array>({
    async start(controller) {
      // Ïª®Ìä∏Î°§Îü¨Ïóê Îç∞Ïù¥ÌÑ∞Î•º ÌÅêÏûâÌïòÎäî WritableStream ÏÉùÏÑ±
      const writableStream = new WritableStream<Uint8Array>({
        write(chunk) {
          controller.enqueue(chunk);
        },
        close() {
          controller.close();
        },
        abort(reason) {
          controller.error(reason);
        }
      });

      const writer = new StaxXmlWriter(writableStream, {
        prettyPrint: true,
        indentString: '    '
      });

      try {
        // XML ÏÉùÏÑ±
        writer.writeStartDocument('1.0', 'utf-8');
        writer.writeStartElement('products', undefined, undefined, {
          count: products.length.toString(),
          generated: new Date().toISOString()
        });
        
        for (const product of products) {
          writer.writeStartElement('product', undefined, undefined, {
            id: product.id,
            category: product.category
          });
          
          writer.writeStartElement('name');
          writer.writeCharacters(product.name);
          writer.writeEndElement();
          
          writer.writeStartElement('price', undefined, undefined, { currency: 'KRW' });
          writer.writeCharacters(product.price.toString());
          writer.writeEndElement();
          
          writer.writeEndElement(); // product
        }
        
        writer.writeEndElement(); // products
        await writer.writeEndDocument();
        
      } catch (error) {
        controller.error(error);
      }
    }
  });

  return new Response(readable, {
    headers: {
      'Content-Type': 'application/xml; charset=utf-8',
      'Cache-Control': 'no-cache',
      'Transfer-Encoding': 'chunked'
    }
  });
});

export default app;
```

##### Í≥†Í∏â Writer Í∏∞Îä•

```typescript
import { StaxXmlWriter } from 'stax-xml';

// ÏÇ¨Ïö©Ïûê Ï†ïÏùò ÏóîÌã∞Ìã∞ÏôÄ ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§Î•º ÏÇ¨Ïö©Ìïú Î©îÎ™®Î¶¨ ÎÇ¥ XML ÏÉùÏÑ±
async function createAdvancedXml() {
  let xmlOutput = '';
  
  const writableStream = new WritableStream<Uint8Array>({
    write(chunk) {
      xmlOutput += new TextDecoder().decode(chunk);
    }
  });

  const writer = new StaxXmlWriter(writableStream, {
    prettyPrint: true,
    indentString: '  ',
    addEntities: [
      { entity: 'company', value: 'ÏïÑÌÅ¨Î©î ÏΩîÌçºÎ†àÏù¥ÏÖò' },
      { entity: 'copyright', value: '¬© 2024' }
    ],
    autoEncodeEntities: true
  });

  // ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ÏôÄ ÏÇ¨Ïö©Ïûê Ï†ïÏùò ÏóîÌã∞Ìã∞Í∞Ä Ìè¨Ìï®Îêú XML ÏûëÏÑ±
  writer.writeStartDocument('1.0', 'utf-8');
  
  writer.writeStartElement('document', 'doc', 'http://example.com/document', { version: '2.0' });
  writer.writeNamespace('meta', 'http://example.com/metadata');
  
  writer.writeStartElement('header', 'meta');
  writer.writeStartElement('title');
  writer.writeCharacters('Ï†úÌíà Ïπ¥ÌÉàÎ°úÍ∑∏');
  writer.writeEndElement();
  
  writer.writeStartElement('company');
  writer.writeCharacters('&company;'); // ÏûêÎèôÏúºÎ°ú Ïù∏ÏΩîÎî©Îê©ÎãàÎã§
  writer.writeEndElement();
  writer.writeEndElement(); // header
  
  writer.writeStartElement('content');
  writer.writeStartElement('item', undefined, undefined, { type: 'featured' });
  
  // Self-closing ÏöîÏÜå
  writer.writeStartElement('thumbnail', undefined, undefined, {
    src: 'image.jpg',
    alt: 'Ï†úÌíà Ïù¥ÎØ∏ÏßÄ'
  });
  writer.writeEndElementSelfClosing();
  
  writer.writeStartElement('description');
  writer.writeCDATA('<p>Ïù¥Í≤ÉÏùÄ CDATA ÎÇ¥Ïùò <b>HTML</b> ÏΩòÌÖêÏ∏†ÏûÖÎãàÎã§</p>');
  writer.writeEndElement();
  
  writer.writeEndElement(); // item
  writer.writeEndElement(); // content
  writer.writeEndElement(); // document
  
  await writer.writeEndDocument();
  
  return xmlOutput;
}

// ÏÇ¨Ïö©Î≤ï
createAdvancedXml().then(xml => {
  console.log('ÏÉùÏÑ±Îêú XML:', xml);
});
```

#### ÏÇ¨Ïö©Ïûê Ï†ïÏùò ÏóîÌã∞Ìã∞ ÏßÄÏõê

```typescript
const parser = new StaxXmlParser(stream, {
  addEntities: [
    { entity: 'custom', value: 'ÏÇ¨Ïö©Ïûê Ï†ïÏùò Í∞í' },
    { entity: 'special', value: '‚òÖ' }
  ]
});
```

#### ÎåÄÏö©Îüâ ÌååÏùº Ï≤òÎ¶¨

```typescript
// ÎåÄÏö©Îüâ XML ÌååÏùºÏùò Ìö®Ïú®Ï†Å Ï≤òÎ¶¨
const parser = new StaxXmlParser(largeXmlStream, {
  maxBufferSize: 128 * 1024, // 128KB Î≤ÑÌçº
  enableBufferCompaction: true
});

// Ï†ÑÏ≤¥ ÌååÏùºÏùÑ Î©îÎ™®Î¶¨Ïóê Î°úÎìúÌïòÏßÄ ÏïäÍ≥† Ïù¥Î≤§Ìä∏Î•º ÏàúÏ∞®Ï†ÅÏúºÎ°ú Ï≤òÎ¶¨
for await (const event of parser) {
  // Í∞Å Ïù¥Î≤§Ìä∏Î•º Í∞úÎ≥ÑÏ†ÅÏúºÎ°ú Ï≤òÎ¶¨
  processEvent(event);
}
```

#### ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ Ï≤òÎ¶¨

```typescript
// ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§Í∞Ä ÏûàÎäî XML
const xmlWithNamespaces = `
  <root xmlns:ns="http://example.com/namespace">
    <ns:element>ÎÇ¥Ïö©</ns:element>
  </root>
`;

for await (const event of parser) {
  if (event.type === XmlEventType.START_ELEMENT) {
    console.log('ÏöîÏÜåÎ™Ö:', event.name);
    console.log('Î°úÏª¨Î™Ö:', event.localName);
    console.log('ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ URI:', event.uri);
    console.log('Ï†ëÎëêÏÇ¨:', event.prefix);
  }
}
```

### üéØ Ïù¥Î≤§Ìä∏ ÌÉÄÏûÖ

- `START_DOCUMENT`: XML Î¨∏ÏÑú ÏãúÏûë
- `END_DOCUMENT`: XML Î¨∏ÏÑú ÎÅù
- `START_ELEMENT`: XML ÏãúÏûë ÌÉúÍ∑∏
- `END_ELEMENT`: XML ÎÅù ÌÉúÍ∑∏
- `CHARACTERS`: ÌÉúÍ∑∏ ÏÇ¨Ïù¥Ïùò ÌÖçÏä§Ìä∏ ÎÇ¥Ïö©
- `CDATA`: CDATA ÏÑπÏÖò ÎÇ¥Ïö©
- `ERROR`: ÌååÏã± Ïò§Î•ò Î∞úÏÉù

### üìö API Ï∞∏Ï°∞

#### StaxXmlParser

```typescript
class StaxXmlParser {
  constructor(
    xmlStream: ReadableStream<Uint8Array>,
    options?: StaxXmlParserOptions
  )
}

interface StaxXmlParserOptions {
  encoding?: string; // Í∏∞Î≥∏Í∞í: 'utf-8'
  addEntities?: { entity: string, value: string }[];
  autoDecodeEntities?: boolean; // Í∏∞Î≥∏Í∞í: true
  maxBufferSize?: number; // Í∏∞Î≥∏Í∞í: 64KB
  enableBufferCompaction?: boolean; // Í∏∞Î≥∏Í∞í: true
}
```

#### StaxXmlWriter

```typescript
class StaxXmlWriter {
  constructor(
    outputStream: WritableStream<Uint8Array>,
    options?: StaxXmlWriterOptions
  )

  // Î¨∏ÏÑú Î†àÎ≤® Î©îÏÑúÎìú
  writeStartDocument(version?: string, encoding?: string): this
  writeEndDocument(): Promise<void>

  // ÏöîÏÜå ÏûëÏÑ± Î©îÏÑúÎìú
  writeStartElement(localName: string, prefix?: string, uri?: string, 
                   attributes?: { [key: string]: string }): this
  writeEndElement(): this
  writeEndElementSelfClosing(): this
  writeEmptyElement(localName: string, prefix?: string, uri?: string, 
                   attributes?: XmlAttribute[], namespaces?: NamespaceDeclaration[]): this

  // ÏÜçÏÑ± Î∞è ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ Î©îÏÑúÎìú
  writeAttribute(localName: string, value: string, prefix?: string, uri?: string): this
  writeNamespace(prefix: string, uri: string): this

  // ÏΩòÌÖêÏ∏† ÏûëÏÑ± Î©îÏÑúÎìú
  writeCharacters(text: string): this
  writeCDATA(cdata: string): this
  writeComment(comment: string): this
  writeProcessingInstruction(target: string, data?: string): this

  // Ïú†Ìã∏Î¶¨Ìã∞ Î©îÏÑúÎìú
  setPrettyPrint(enabled: boolean): this
  setIndentString(indentString: string): this
  isPrettyPrintEnabled(): boolean
  getIndentString(): string
}

interface StaxXmlWriterOptions {
  encoding?: string; // Í∏∞Î≥∏Í∞í: 'utf-8'
  prettyPrint?: boolean; // Í∏∞Î≥∏Í∞í: false
  indentString?: string; // Í∏∞Î≥∏Í∞í: '  '
  addEntities?: { entity: string, value: string }[];
  autoEncodeEntities?: boolean; // Í∏∞Î≥∏Í∞í: true
  namespaces?: NamespaceDeclaration[];
}

interface XmlAttribute {
  localName: string;
  value: string;
  prefix?: string;
  uri?: string;
}

interface NamespaceDeclaration {
  prefix?: string;
  uri: string;
}
```

### üß™ ÌÖåÏä§Ìä∏

```bash
bun test
```

### üìÑ ÎùºÏù¥ÏÑ†Ïä§

MIT

### ü§ù Í∏∞Ïó¨ÌïòÍ∏∞

Í∏∞Ïó¨Î•º ÌôòÏòÅÌï©ÎãàÎã§! Pull RequestÎ•º ÏûêÏú†Î°≠Í≤å Ï†úÏ∂úÌï¥ Ï£ºÏÑ∏Ïöî.
