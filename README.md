# StAX-XML

[English](#english) | [ÌïúÍµ≠Ïñ¥](#korean)

---

## English

A high-performance, pull-based XML parser for JavaScript/TypeScript inspired by Java's StAX (Streaming API for XML). It offers both **fully asynchronous, stream-based parsing** for large files and **synchronous parsing** for smaller, in-memory XML documents. Unlike traditional XML-to-JSON mappers, StAX-XML allows you to map XML data to any custom structure you desire while efficiently handling XML files through streaming or direct string processing.

### üöÄ Features

- **Fully Asynchronous (Stream-based)**: For memory-efficient processing of large XML files.
- **Synchronous (String-based)**: For high-performance parsing of smaller, in-memory XML strings.
- **Pull-based Parsing**: Stream-based approach for memory-efficient processing of large XML files
- **Custom Mapping**: Map XML data to any structure you want, not just plain JSON objects
- **High Performance**: Optimized for speed and low memory usage
- **Universal Compatibility**: Works in Node.js, Bun, Deno, and web browsers using only Web Standard APIs
- **Namespace Support**: Basic XML namespace handling
- **Entity Support**: Built-in entity decoding with custom entity support
- **TypeScript Ready**: Full TypeScript support with comprehensive type definitions

### üì¶ Installation

```bash
# npm
npm install stax-xml
# yarn
yarn add stax-xml
# pnpm
pnpm add stax-xml
# bun
bun add stax-xml
# deno
deno add npm:stax-xml
```

### üîß Quick Start

#### Parsing XML String (Asynchronous - StaxXmlParser)

```typescript
import { StaxXmlParser, XmlEventType } from 'stax-xml';

// Create a ReadableStream from XML string
const xmlContent = `
  <books>
    <book id="1">
      <title>The Great Gatsby</title>
      <author>F. Scott Fitzgerald</author>
    </book>
    <book id="2">
      <title>To Kill a Mockingbird</title>
      <author>Harper Lee</author>
    </book>
  </books>
`;

const stream = new ReadableStream({
  start(controller) {
    controller.enqueue(new TextEncoder().encode(xmlContent));
    controller.close();
  }
});

// Parse XML with pull-based approach
const parser = new StaxXmlParser(stream);
const books = [];
let currentBook = null;
let currentText = '';

for await (const event of parser) {
  switch (event.type) {
    case XmlEventType.START_ELEMENT:
      if (event.name === 'book') {
        currentBook = { id: event.attributes?.id || '', title: '', author: '' };
      }
      currentText = '';
      break;
      
    case XmlEventType.CHARACTERS:
      currentText += event.data;
      break;
      
    case XmlEventType.END_ELEMENT:
      if (currentBook) {
        if (event.name === 'title') {
          currentBook.title = currentText.trim();
        } else if (event.name === 'author') {
          currentBook.author = currentText.trim();
        } else if (event.name === 'book') {
          books.push(currentBook);
          currentBook = null;
        }
      }
      break;
  }
}

console.log(books);
// Output: [
//   { id: "1", title: "The Great Gatsby", author: "F. Scott Fitzgerald" },
//   { id: "2", title: "To Kill a Mockingbird", author: "Harper Lee" }
// ]
```

#### Parsing XML String (Synchronous - StaxXmlParserSync)

```typescript
import { StaxXmlParserSync, XmlEventType } from 'stax-xml';

const xmlContent = `
  <catalog>
    <product id="P001">
      <name>Laptop</name>
      <price>1200</price>
    </product>
    <product id="P002">
      <name>Mouse</name>
      <price>25</price>
    </product>
  </catalog>
`;

const parser = new StaxXmlParserSync(xmlContent);
const products = [];
let currentProduct = null;
let currentText = '';

for (const event of parser) { // Use for...of for synchronous iteration
  switch (event.type) {
    case XmlEventType.START_ELEMENT:
      if (event.name === 'product') {
        currentProduct = { id: event.attributes?.id || '', name: '', price: 0 };
      } else if (event.name === 'name' || event.name === 'price') {
        currentText = ''; // Reset text buffer for new element
      }
      break;
      
    case XmlEventType.CHARACTERS:
      currentText += event.value; // Use event.value for synchronous parser
      break;
      
    case XmlEventType.END_ELEMENT:
      if (currentProduct) {
        if (event.name === 'name') {
          currentProduct.name = currentText.trim();
        } else if (event.name === 'price') {
          currentProduct.price = parseFloat(currentText.trim());
        } else if (event.name === 'product') {
          products.push(currentProduct);
          currentProduct = null;
        }
      }
      break;
  }
}

console.log(products);
// Output: [
//   { id: "P001", name: "Laptop", price: 1200 },
//   { id: "P002", name: "Mouse", price: 25 }
// ]
```

#### Parsing Remote XML with Fetch

```typescript
import { StaxXmlParser, XmlEventType } from 'stax-xml';

async function parseRemoteXml(url: string) {
  try {
    // Fetch XML from remote URL
    const response = await fetch(url);
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    // Get the response body as a ReadableStream
    const xmlStream = response.body;
    
    if (!xmlStream) {
      throw new Error('No response body');
    }
    
    // Parse the XML stream directly
    const parser = new StaxXmlParser(xmlStream);
    const results = [];
    let currentItem = {};
    let currentText = '';
    
    for await (const event of parser) {
      switch (event.type) {
        case XmlEventType.START_ELEMENT:
          if (event.name === 'item') {
            currentItem = {};
          }
          currentText = '';
          break;
          
        case XmlEventType.CHARACTERS:
          currentText += event.data;
          break;
          
        case XmlEventType.END_ELEMENT:
          if (event.name === 'title' || event.name === 'description') {
            currentItem[event.name] = currentText.trim();
          } else if (event.name === 'item') {
            results.push(currentItem);
          }
          break;
      }
    }
    
    return results;
  } catch (error) {
    console.error('Error parsing remote XML:', error);
    throw error;
  }
}

// Usage examples
const rssUrl = 'https://example.com/feed.xml';
const xmlApiUrl = 'https://api.example.com/data.xml';

// Parse RSS feed
parseRemoteXml(rssUrl)
  .then(items => {
    console.log('RSS items:', items);
  })
  .catch(error => {
    console.error('Failed to parse RSS:', error);
  });

// Parse API response
parseRemoteXml(xmlApiUrl)
  .then(data => {
    console.log('API data:', data);
  })
  .catch(error => {
    console.error('Failed to parse API response:', error);
  });
```

### üåê Platform Compatibility

StAX-XML uses only Web Standard APIs, making it compatible with:

- **Node.js** (v18+)
- **Bun** (any version)
- **Deno** (any version)
- **Web Browsers** (modern browsers)
- **Edge Runtime** (Vercel, Cloudflare Workers, etc.)

### ‚ö° Advanced Usage

#### StaxXmlWriter - Creating XML Documents

StAX-XML also includes a powerful XML writer that allows you to generate XML documents programmatically.

##### Writing to Local File

```typescript
import { StaxXmlWriter } from 'stax-xml';
import { createWriteStream } from 'fs';

// For Node.js - create a WritableStream from fs
async function createLocalXmlFile() {
  const fileStream = createWriteStream('./output.xml');
  
  // Convert Node.js WriteStream to Web Standard WritableStream
  const writableStream = new WritableStream<Uint8Array>({
    write(chunk) {
      fileStream.write(chunk);
    },
    close() {
      fileStream.end();
    }
  });

  const writer = new StaxXmlWriter(writableStream, {
    prettyPrint: true,
    indentString: '  '
  });

  // Write XML document
  await writer.writeStartDocument('1.0', 'utf-8');
  
  await writer.writeStartElement('catalog', { attributes: { version: '1.0' } });
  
  await writer.writeStartElement('product', { attributes: { id: '001' } });
  
  await writer.writeStartElement('name');
  await writer.writeCharacters('Laptop Computer');
  await writer.writeEndElement();
  
  await writer.writeStartElement('price', { attributes: { currency: 'USD' } });
  await writer.writeCharacters('999.99');
  await writer.writeEndElement();
  
  await writer.writeEndElement(); // product
  await writer.writeEndElement(); // catalog
  
  await writer.writeEndDocument();
  console.log('XML file created successfully!');
}

createLocalXmlFile();
```

##### Express.js Middleware - XML Response

```typescript
import express from 'express';
import { StaxXmlWriter } from 'stax-xml';

const app = express();

// Middleware to create XML response
app.get('/api/users', async (req, res) => {
  try {
    // Sample data
    const users = [
      { id: 1, name: 'John Doe', email: 'john@example.com' },
      { id: 2, name: 'Jane Smith', email: 'jane@example.com' }
    ];

    // Create a WritableStream that writes to Express response
    const writableStream = new WritableStream<Uint8Array>({
      write(chunk) {
        res.write(chunk);
      },
      close() {
        res.end();
      }
    });

    const writer = new StaxXmlWriter(writableStream, {
      prettyPrint: true,
      indentString: '  '
    });

    // Set appropriate headers
    res.setHeader('Content-Type', 'application/xml; charset=utf-8');
    res.setHeader('Cache-Control', 'no-cache');

    // Write XML
    await writer.writeStartDocument('1.0', 'utf-8');
    await writer.writeStartElement('users');
    
    for (const user of users) {
      await writer.writeStartElement('user', { attributes: { id: user.id.toString() } });
      
      await writer.writeStartElement('name');
      await writer.writeCharacters(user.name);
      await writer.writeEndElement();
      
      await writer.writeStartElement('email');
      await writer.writeCharacters(user.email);
      await writer.writeEndElement();
      
      await writer.writeEndElement(); // user
    }
    
    await writer.writeEndElement(); // users
    await writer.writeEndDocument();
    
  } catch (error) {
    res.status(500).json({ error: 'Failed to generate XML' });
  }
});

app.listen(3000, () => {
  console.log('Server running on port 3000');
});
```

##### Hono Framework - Streaming XML Response

```typescript
import { Hono } from 'hono';
import { StaxXmlWriter } from 'stax-xml';

const app = new Hono();

app.get('/api/products', async (c) => {
  // Sample product data
  const products = [
    { id: 'P001', name: 'Smartphone', price: 699.99, category: 'Electronics' },
    { id: 'P002', name: 'Headphones', price: 199.99, category: 'Electronics' },
    { id: 'P003', name: 'Coffee Maker', price: 149.99, category: 'Appliances' }
  ];

  // Create ReadableStream for streaming response
  const readable = new ReadableStream<Uint8Array>({
    async start(controller) {
      // Create a WritableStream that enqueues data to the controller
      const writableStream = new WritableStream<Uint8Array>({
        write(chunk) {
          controller.enqueue(chunk);
        },
        close() {
          controller.close();
        },
        abort(reason) {
          controller.error(reason);
        }
      });

      const writer = new StaxXmlWriter(writableStream, {
        prettyPrint: true,
        indentString: '    '
      });

      try {
        // Generate XML
        await writer.writeStartDocument('1.0', 'utf-8');
        await writer.writeStartElement('products', {
          attributes: {
            count: products.length.toString(),
            generated: new Date().toISOString()
          }
        });
        
        for (const product of products) {
          await writer.writeStartElement('product', {
            attributes: {
              id: product.id,
              category: product.category
            }
          });
          
          await writer.writeStartElement('name');
          await writer.writeCharacters(product.name);
          await writer.writeEndElement();
          
          await writer.writeStartElement('price', { attributes: { currency: 'USD' } });
          await writer.writeCharacters(product.price.toString());
          await writer.writeEndElement();
          
          await writer.writeEndElement(); // product
        }
        
        await writer.writeEndElement(); // products
        await writer.writeEndDocument();
        
      } catch (error) {
        controller.error(error);
      }
    }
  });

  return new Response(readable, {
    headers: {
      'Content-Type': 'application/xml; charset=utf-8',
      'Cache-Control': 'no-cache',
      'Transfer-Encoding': 'chunked'
    }
  });
});

export default app;
```

##### Advanced Writer Features

```typescript
import { StaxXmlWriter } from 'stax-xml';

// Create in-memory XML with custom entities and namespaces
async function createAdvancedXml() {
  let xmlOutput = '';
  
  const writableStream = new WritableStream<Uint8Array>({
    write(chunk) {
      xmlOutput += new TextDecoder().decode(chunk);
    }
  });

  const writer = new StaxXmlWriter(writableStream, {
    prettyPrint: true,
    indentString: '  ',
    addEntities: [
      { entity: 'company', value: 'Acme Corporation' },
      { entity: 'copyright', value: '¬© 2024' }
    ],
    autoEncodeEntities: true
  });

  // Write XML with namespaces and custom entities
  await writer.writeStartDocument('1.0', 'utf-8');
  
  await writer.writeStartElement('document', { 
    prefix: 'doc', 
    uri: 'http://example.com/document', 
    attributes: { version: '2.0' } 
  });
  await writer.writeNamespace('meta', 'http://example.com/metadata');
  
  await writer.writeStartElement('header', { prefix: 'meta' });
  await writer.writeStartElement('title');
  await writer.writeCharacters('Product Catalog');
  await writer.writeEndElement();
  
  await writer.writeStartElement('company');
  await writer.writeCharacters('&company;'); // Will be encoded automatically
  await writer.writeEndElement();
  await writer.writeEndElement(); // header
  
  await writer.writeStartElement('content');
  await writer.writeStartElement('item', { attributes: { type: 'featured' } });
  
  // Self-closing element
  await writer.writeStartElement('thumbnail', {
    attributes: {
      src: 'image.jpg',
      alt: 'Product Image'
    },
    selfClosing: true
  });
  
  await writer.writeStartElement('description');
  await writer.writeCDATA('<p>This is <b>HTML</b> content in CDATA</p>');
  await writer.writeEndElement();
  
  await writer.writeEndElement(); // item
  await writer.writeEndElement(); // content
  await writer.writeEndElement(); // document
  
  await writer.writeEndDocument();
  
  return xmlOutput;
}

// Usage
createAdvancedXml().then(xml => {
  console.log('Generated XML:', xml);
});
```

##### New Unified WriteElementOptions API

StaxXmlWriter now supports a new unified API that simplifies element creation by consolidating all options into a single `WriteElementOptions` object:

```typescript
import { StaxXmlWriter, WriteElementOptions } from 'stax-xml';

async function createXmlWithNewAPI() {
  let xmlOutput = '';
  
  const writableStream = new WritableStream<Uint8Array>({
    write(chunk) {
      xmlOutput += new TextDecoder().decode(chunk);
    }
  });

  const writer = new StaxXmlWriter(writableStream, { prettyPrint: true });

  await writer.writeStartDocument();
  
  // Basic element with attributes
  await writer.writeStartElement('catalog', {
    attributes: { version: '2.0', xmlns: 'http://example.com/catalog' }
  });
  
  // Element with namespace and attributes
  await writer.writeStartElement('product', {
    prefix: 'cat',
    uri: 'http://example.com/catalog',
    attributes: { id: '001', featured: 'true' }
  });
  
  await writer.writeStartElement('name');
  await writer.writeCharacters('Premium Laptop');
  await writer.writeEndElement();
  
  // Self-closing element with attributes
  await writer.writeStartElement('thumbnail', {
    attributes: {
      src: 'image.jpg',
      alt: 'Product Image',
      width: '200'
    },
    selfClosing: true  // No need to call writeEndElement()
  });
  
  // Simple self-closing element
  await writer.writeStartElement('br', { selfClosing: true });
  
  await writer.writeEndElement(); // product
  await writer.writeEndElement(); // catalog
  
  await writer.writeEndDocument();
  return xmlOutput;
}

// Output:
// <?xml version="1.0" encoding="UTF-8"?>
// <catalog version="2.0" xmlns="http://example.com/catalog">
//   <cat:product id="001" featured="true" xmlns:cat="http://example.com/catalog">
//     <name>Premium Laptop</name>
//     <thumbnail src="image.jpg" alt="Product Image" width="200"/>
//     <br/>
//   </cat:product>
// </catalog>
```

**Key Benefits of the New API:**

- **Unified Parameters**: All element options (attributes, namespace, self-closing) are consolidated into a single options object
- **Self-Closing Support**: Set `selfClosing: true` to automatically close elements without calling `writeEndElement()`
- **Cleaner Syntax**: More intuitive and readable code structure
- **Type Safety**: Full TypeScript support with comprehensive type definitions

**Usage Examples:**

```typescript
// Simple element with attributes
await writer.writeStartElement('img', {
  attributes: {
    src: 'image.jpg',
    alt: 'Image'
  },
  selfClosing: true
});

// Element with namespace
await writer.writeStartElement('title', {
  prefix: 'html',
  uri: 'http://www.w3.org/1999/xhtml',
  attributes: { lang: 'en' }
});
```

#### Custom Entity Support

```typescript
const parser = new StaxXmlParser(stream, {
  addEntities: [
    { entity: 'custom', value: 'Custom Value' },
    { entity: 'special', value: '‚òÖ' }
  ]
});
```

#### Large File Processing

```typescript
// Efficient processing of large XML files
const parser = new StaxXmlParser(largeXmlStream, {
  maxBufferSize: 128 * 1024, // 128KB buffer
  enableBufferCompaction: true
});

// Process events as they come, without loading entire file into memory
for await (const event of parser) {
  // Handle each event individually
  processEvent(event);
}
```

#### Namespace Handling

```typescript
// XML with namespaces
const xmlWithNamespaces = `
  <root xmlns:ns="http://example.com/namespace">
    <ns:element>Content</ns:element>
  </root>
`;

for await (const event of parser) {
  if (event.type === XmlEventType.START_ELEMENT) {
    console.log('Element:', event.name);
    console.log('Local name:', event.localName);
    console.log('Namespace URI:', event.uri);
    console.log('Prefix:', event.prefix);
  }
}
```

### üéØ Event Types

- `START_DOCUMENT`: Beginning of XML document
- `END_DOCUMENT`: End of XML document
- `START_ELEMENT`: Opening XML tag
- `END_ELEMENT`: Closing XML tag
- `CHARACTERS`: Text content between tags
- `CDATA`: CDATA section content
- `ERROR`: Parse error occurred

### üìö API Reference

#### StaxXmlParser

```typescript
class StaxXmlParser {
  constructor(
    xmlStream: ReadableStream<Uint8Array>,
    options?: StaxXmlParserOptions
  )
}

interface StaxXmlParserOptions {
  encoding?: string; // Default: 'utf-8'
  addEntities?: { entity: string, value: string }[];
  autoDecodeEntities?: boolean; // Default: true
  maxBufferSize?: number; // Default: 64KB
  enableBufferCompaction?: boolean; // Default: true
}
```

#### StaxXmlParserSync

```typescript
class StaxXmlParserSync {
  constructor(
    xmlString: string,
    options?: StaxXmlParserSyncOptions
  )
}

interface StaxXmlParserSyncOptions {
  autoDecodeEntities?: boolean; // Default: true
  addEntities?: { entity: string, value: string }[];
}
```

#### StaxXmlWriter

```typescript
interface WriteElementOptions {
  prefix?: string;              // Namespace prefix
  uri?: string;                 // Namespace URI
  attributes?: Record<string, string>; // Element attributes
  selfClosing?: boolean;        // Whether to create a self-closing tag
}

class StaxXmlWriter {
  constructor(
    outputStream: WritableStream<Uint8Array>,
    options?: StaxXmlWriterOptions
  )

  // Document Level Methods
  writeStartDocument(version?: string, encoding?: string): this
  writeEndDocument(): Promise<void>

  // Element Writing Methods
  writeStartElement(localName: string, options?: WriteElementOptions): this
  writeEndElement(): this

  // Attribute and Namespace Methods
  writeAttribute(localName: string, value: string, prefix?: string, uri?: string): this
  writeNamespace(prefix: string, uri: string): this

  // Content Writing Methods
  writeCharacters(text: string): this
  writeCDATA(cdata: string): this
  writeComment(comment: string): this
  writeProcessingInstruction(target: string, data?: string): this

  // Utility Methods
  setPrettyPrint(enabled: boolean): this
  setIndentString(indentString: string): this
  isPrettyPrintEnabled(): boolean
  getIndentString(): string
}

interface StaxXmlWriterOptions {
  encoding?: string; // Default: 'utf-8'
  prettyPrint?: boolean; // Default: false
  indentString?: string; // Default: '  '
  addEntities?: { entity: string, value: string }[];
  autoEncodeEntities?: boolean; // Default: true
  namespaces?: NamespaceDeclaration[];
}

interface XmlAttribute {
  localName: string;
  value: string;
  prefix?: string;
  uri?: string;
}

interface NamespaceDeclaration {
  prefix?: string;
  uri: string;
}
```

### üß™ Testing

```bash
bun test
```

### üìÅ Sample File Sources

Sources of sample XML files used in testing:

- `books.xml`: [Microsoft XML Document Examples](https://learn.microsoft.com/en-us/previous-versions/windows/desktop/ms762271(v=vs.85))
- `simple-namespace.xml`: [W3Schools XML Namespaces Guide](https://www.w3schools.com/xml/xml_namespaces.asp)
- `treebank_e.xml`: [University of Washington XML Data Repository](https://aiweb.cs.washington.edu/research/projects/xmltk/xmldata/www/repository.html)

### üìÑ License

MIT

### ü§ù Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

---

## Korean

JavaÏùò StAX(Streaming API for XML)ÏóêÏÑú ÏòÅÍ∞êÏùÑ Î∞õÏùÄ Í≥†ÏÑ±Îä• pull Î∞©ÏãùÏùò JavaScript/TypeScript XML ÌååÏÑúÏûÖÎãàÎã§. **ÎåÄÏö©Îüâ ÌååÏùºÏùÑ ÏúÑÌïú ÏôÑÏ†Ñ ÎπÑÎèôÍ∏∞ Ïä§Ìä∏Î¶º Í∏∞Î∞ò ÌååÏã±**Í≥º **ÏûëÏùÄ Ïù∏Î©îÎ™®Î¶¨ XML Î¨∏ÏÑúÎ•º ÏúÑÌïú ÎèôÍ∏∞ ÌååÏã±**ÏùÑ Î™®Îëê Ï†úÍ≥µÌï©ÎãàÎã§. Í∏∞Ï°¥Ïùò XML-JSON Îß§ÌçºÏôÄ Îã¨Î¶¨, StAX-XMLÏùÑ ÏÇ¨Ïö©ÌïòÎ©¥ XML Îç∞Ïù¥ÌÑ∞Î•º ÏõêÌïòÎäî ÏûÑÏùòÏùò Íµ¨Ï°∞Î°ú Îß§ÌïëÌï† Ïàò ÏûàÏúºÎ©∞, Ïä§Ìä∏Î¶¨Î∞ç ÎòêÎäî ÏßÅÏ†ë Î¨∏ÏûêÏó¥ Ï≤òÎ¶¨Î•º ÌÜµÌï¥ XML ÌååÏùºÏùÑ Ìö®Ïú®Ï†ÅÏúºÎ°ú Ï≤òÎ¶¨Ìï† Ïàò ÏûàÏäµÎãàÎã§.

### üöÄ Ï£ºÏöî Í∏∞Îä•

- **ÏôÑÏ†Ñ ÎπÑÎèôÍ∏∞ (Ïä§Ìä∏Î¶º Í∏∞Î∞ò)**: ÎåÄÏö©Îüâ XML ÌååÏùºÏùò Î©îÎ™®Î¶¨ Ìö®Ïú®Ï†Å Ï≤òÎ¶¨Î•º ÏúÑÌïú Ïä§Ìä∏Î¶º Í∏∞Î∞ò Ï†ëÍ∑º
- **ÎèôÍ∏∞ (Î¨∏ÏûêÏó¥ Í∏∞Î∞ò)**: ÏûëÏùÄ Ïù∏Î©îÎ™®Î¶¨ XML Î¨∏ÏûêÏó¥Ïùò Í≥†ÏÑ±Îä• ÌååÏã±ÏùÑ ÏúÑÌïú ÏßÅÏ†ë Î¨∏ÏûêÏó¥ Ï≤òÎ¶¨
- **Pull Î∞©Ïãù ÌååÏã±**: ÎåÄÏö©Îüâ XML ÌååÏùºÏùò Î©îÎ™®Î¶¨ Ìö®Ïú®Ï†Å Ï≤òÎ¶¨Î•º ÏúÑÌïú Ïä§Ìä∏Î¶º Í∏∞Î∞ò Ï†ëÍ∑º
- **ÏÇ¨Ïö©Ïûê Ï†ïÏùò Îß§Ìïë**: Îã®ÏàúÌïú JSON Í∞ùÏ≤¥Í∞Ä ÏïÑÎãå ÏõêÌïòÎäî Íµ¨Ï°∞Î°ú XML Îç∞Ïù¥ÌÑ∞ Îß§Ìïë Í∞ÄÎä•
- **Í≥†ÏÑ±Îä•**: ÏÜçÎèÑÏôÄ ÎÇÆÏùÄ Î©îÎ™®Î¶¨ ÏÇ¨Ïö©ÎüâÏóê ÏµúÏ†ÅÌôî
- **Î≤îÏö© Ìò∏ÌôòÏÑ±**: Ïõπ ÌëúÏ§Ä APIÎßå ÏÇ¨Ïö©ÌïòÏó¨ Node.js, Bun, Deno, Ïõπ Î∏åÎùºÏö∞Ï†ÄÏóêÏÑú Î™®Îëê ÎèôÏûë
- **ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ ÏßÄÏõê**: Í∏∞Î≥∏Ï†ÅÏù∏ XML ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ Ï≤òÎ¶¨
- **ÏóîÌã∞Ìã∞ ÏßÄÏõê**: ÎÇ¥Ïû• ÏóîÌã∞Ìã∞ ÎîîÏΩîÎî© Î∞è ÏÇ¨Ïö©Ïûê Ï†ïÏùò ÏóîÌã∞Ìã∞ ÏßÄÏõê
- **TypeScript ÏßÄÏõê**: Ìè¨Í¥ÑÏ†ÅÏù∏ ÌÉÄÏûÖ Ï†ïÏùòÎ°ú ÏôÑÏ†ÑÌïú TypeScript ÏßÄÏõê

### üì¶ ÏÑ§Ïπò

```bash
# npm
npm install stax-xml
# yarn
yarn add stax-xml
# pnpm
pnpm add stax-xml
# bun
bun add stax-xml
# deno
deno add npm:stax-xml
```

### üîß Îπ†Î•∏ ÏãúÏûë

#### XML Î¨∏ÏûêÏó¥ ÌååÏã± (ÎπÑÎèôÍ∏∞ - StaxXmlParser)

```typescript
import { StaxXmlParser, XmlEventType } from 'stax-xml';

// XML Î¨∏ÏûêÏó¥Î°úÎ∂ÄÌÑ∞ ReadableStream ÏÉùÏÑ±
const xmlContent = `
  <books>
    <book id="1">
      <title>ÏúÑÎåÄÌïú Í∞úÏ∏†ÎπÑ</title>
      <author>F. Ïä§ÏΩß ÌîºÏ∏†Ï†úÎü¥Îìú</author>
    </book>
    <book id="2">
      <title>ÏïµÎ¨¥ÏÉà Ï£ΩÏù¥Í∏∞</title>
      <author>ÌïòÌçº Î¶¨</author>
    </book>
  </books>
`;

const stream = new ReadableStream({
  start(controller) {
    controller.enqueue(new TextEncoder().encode(xmlContent));
    controller.close();
  }
});

// Pull Î∞©ÏãùÏúºÎ°ú XML ÌååÏã±
const parser = new StaxXmlParser(stream);
const books = [];
let currentBook = null;
let currentText = '';

for await (const event of parser) {
  switch (event.type) {
    case XmlEventType.START_ELEMENT:
      if (event.name === 'book') {
        currentBook = { id: event.attributes?.id || '', title: '', author: '' };
      }
      currentText = '';
      break;
      
    case XmlEventType.CHARACTERS:
      currentText += event.data;
      break;
      
    case XmlEventType.END_ELEMENT:
      if (currentBook) {
        if (event.name === 'title') {
          currentBook.title = currentText.trim();
        } else if (event.name === 'author') {
          currentBook.author = currentText.trim();
        } else if (event.name === 'book') {
          books.push(currentBook);
          currentBook = null;
        }
      }
      break;
  }
}

console.log(books);
// Ï∂úÎ†•: [
//   { id: "1", title: "ÏúÑÎåÄÌïú Í∞úÏ∏†ÎπÑ", author: "F. Ïä§ÏΩß ÌîºÏ∏†Ï†úÎü¥Îìú" },
//   { id: "2", title: "ÏïµÎ¨¥ÏÉà Ï£ΩÏù¥Í∏∞", author: "ÌïòÌçº Î¶¨" }
// ]
```

#### XML Î¨∏ÏûêÏó¥ ÌååÏã± (ÎèôÍ∏∞ - StaxXmlParserSync)

```typescript
import { StaxXmlParserSync, XmlEventType } from 'stax-xml';

const xmlContent = `
  <catalog>
    <product id="P001">
      <name>ÎÖ∏Ìä∏Î∂Å</name>
      <price>1200</price>
    </product>
    <product id="P002">
      <name>ÎßàÏö∞Ïä§</name>
      <price>25</price>
    </product>
  </catalog>
`;

const parser = new StaxXmlParserSync(xmlContent);
const products = [];
let currentProduct = null;
let currentText = '';

for (const event of parser) { // ÎèôÍ∏∞ Î∞òÎ≥µÏùÑ ÏúÑÌï¥ for...of ÏÇ¨Ïö©
  switch (event.type) {
    case XmlEventType.START_ELEMENT:
      if (event.name === 'product') {
        currentProduct = { id: event.attributes?.id || '', name: '', price: 0 };
      } else if (event.name === 'name' || event.name === 'price') {
        currentText = ''; // ÏÉà ÏöîÏÜåÎ•º ÏúÑÌï¥ ÌÖçÏä§Ìä∏ Î≤ÑÌçº Ï¥àÍ∏∞Ìôî
      }
      break;
      
    case XmlEventType.CHARACTERS:
      currentText += event.value; // ÎèôÍ∏∞ ÌååÏÑúÏùò Í≤ΩÏö∞ event.value ÏÇ¨Ïö©
      break;
      
    case XmlEventType.END_ELEMENT:
      if (currentProduct) {
        if (event.name === 'name') {
          currentProduct.name = currentText.trim();
        } else if (event.name === 'price') {
          currentProduct.price = parseFloat(currentText.trim());
        } else if (event.name === 'product') {
          products.push(currentProduct);
          currentProduct = null;
        }
      }
      break;
  }
}

console.log(products);
// Ï∂úÎ†•: [
//   { id: "P001", name: "ÎÖ∏Ìä∏Î∂Å", price: 1200 },
//   { id: "P002", name: "ÎßàÏö∞Ïä§", price: 25 }
// ]
```

#### FetchÎ°ú ÏõêÍ≤© XML ÌååÏã±

```typescript
import { StaxXmlParser, XmlEventType } from 'stax-xml';

async function parseRemoteXml(url: string) {
  try {
    // ÏõêÍ≤© URLÏóêÏÑú XML Í∞ÄÏ†∏Ïò§Í∏∞
    const response = await fetch(url);
    
    if (!response.ok) {
      throw new Error(`HTTP Ïò§Î•ò! ÏÉÅÌÉú: ${response.status}`);
    }
    
    // ÏùëÎãµ Î≥∏Î¨∏ÏùÑ ReadableStreamÏúºÎ°ú Í∞ÄÏ†∏Ïò§Í∏∞
    const xmlStream = response.body;
    
    if (!xmlStream) {
      throw new Error('ÏùëÎãµ Î≥∏Î¨∏Ïù¥ ÏóÜÏäµÎãàÎã§');
    }
    
    // XML Ïä§Ìä∏Î¶ºÏùÑ ÏßÅÏ†ë ÌååÏã±
    const parser = new StaxXmlParser(xmlStream);
    const results = [];
    let currentItem = {};
    let currentText = '';
    
    for await (const event of parser) {
      switch (event.type) {
        case XmlEventType.START_ELEMENT:
          if (event.name === 'item') {
            currentItem = {};
          }
          currentText = '';
          break;
          
        case XmlEventType.CHARACTERS:
          currentText += event.data;
          break;
          
        case XmlEventType.END_ELEMENT:
          if (event.name === 'title' || event.name === 'description') {
            currentItem[event.name] = currentText.trim();
          } else if (event.name === 'item') {
            results.push(currentItem);
          }
          break;
      }
    }
    
    return results;
  } catch (error) {
    console.error('ÏõêÍ≤© XML ÌååÏã± Ïò§Î•ò:', error);
    throw error;
  }
}

// ÏÇ¨Ïö© ÏòàÏ†ú
const rssUrl = 'https://example.com/feed.xml';
const xmlApiUrl = 'https://api.example.com/data.xml';

// RSS ÌîºÎìú ÌååÏã±
parseRemoteXml(rssUrl)
  .then(items => {
    console.log('RSS Ìï≠Î™©:', items);
  })
  .catch(error => {
    console.error('RSS ÌååÏã± Ïã§Ìå®:', error);
  });

// API ÏùëÎãµ ÌååÏã±
parseRemoteXml(xmlApiUrl)
  .then(data => {
    console.log('API Îç∞Ïù¥ÌÑ∞:', data);
  })
  .catch(error => {
    console.error('API ÏùëÎãµ ÌååÏã± Ïã§Ìå®:', error);
  });
```

### üåê ÌîåÎû´Ìèº Ìò∏ÌôòÏÑ±

StAX-XMLÏùÄ Ïõπ ÌëúÏ§Ä APIÎßåÏùÑ ÏÇ¨Ïö©ÌïòÏó¨ Îã§Ïùå ÌôòÍ≤ΩÏóêÏÑú ÎèôÏûëÌï©ÎãàÎã§:

- **Node.js** (v18+)
- **Bun** (Î™®Îì† Î≤ÑÏ†Ñ)
- **Deno** (Î™®Îì† Î≤ÑÏ†Ñ)
- **Ïõπ Î∏åÎùºÏö∞Ï†Ä** (ÏµúÏã† Î∏åÎùºÏö∞Ï†Ä)
- **Edge Runtime** (Vercel, Cloudflare Workers Îì±)

### ‚ö° Í≥†Í∏â ÏÇ¨Ïö©Î≤ï

#### StaxXmlWriter - XML Î¨∏ÏÑú ÏÉùÏÑ±

StAX-XMLÏùÄ ÌîÑÎ°úÍ∑∏ÎûòÎ∞ç Î∞©ÏãùÏúºÎ°ú XML Î¨∏ÏÑúÎ•º ÏÉùÏÑ±Ìï† Ïàò ÏûàÎäî Í∞ïÎ†•Ìïú XML ÏûëÏÑ±Í∏∞ÎèÑ Ìè¨Ìï®ÌïòÍ≥† ÏûàÏäµÎãàÎã§.

##### Î°úÏª¨ ÌååÏùº ÏÉùÏÑ±

```typescript
import { StaxXmlWriter } from 'stax-xml';
import { createWriteStream } from 'fs';

// Node.jsÏö© - fsÏóêÏÑú WritableStream ÏÉùÏÑ±
async function createLocalXmlFile() {
  const fileStream = createWriteStream('./output.xml');
  
  // Node.js WriteStreamÏùÑ Ïõπ ÌëúÏ§Ä WritableStreamÏúºÎ°ú Î≥ÄÌôò
  const writableStream = new WritableStream<Uint8Array>({
    write(chunk) {
      fileStream.write(chunk);
    },
    close() {
      fileStream.end();
    }
  });

  const writer = new StaxXmlWriter(writableStream, {
    prettyPrint: true,
    indentString: '  '
  });

  // XML Î¨∏ÏÑú ÏûëÏÑ±
  await writer.writeStartDocument('1.0', 'utf-8');
  
  await writer.writeStartElement('catalog', { attributes: { version: '1.0' } });
  
  await writer.writeStartElement('product', { attributes: { id: '001' } });
  
  await writer.writeStartElement('name');
  await writer.writeCharacters('ÎÖ∏Ìä∏Î∂Å Ïª¥Ìì®ÌÑ∞');
  await writer.writeEndElement();
  
  await writer.writeStartElement('price', { attributes: { currency: 'KRW' } });
  await writer.writeCharacters('1299000');
  await writer.writeEndElement();
  
  await writer.writeEndElement(); // product
  await writer.writeEndElement(); // catalog
  
  await writer.writeEndDocument();
  console.log('XML ÌååÏùºÏù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§!');
}

createLocalXmlFile();
```

##### Express.js ÎØ∏Îì§Ïõ®Ïñ¥ - XML ÏùëÎãµ

```typescript
import express from 'express';
import { StaxXmlWriter } from 'stax-xml';

const app = express();

// XML ÏùëÎãµÏùÑ ÏÉùÏÑ±ÌïòÎäî ÎØ∏Îì§Ïõ®Ïñ¥
app.get('/api/users', async (req, res) => {
  try {
    // ÏÉòÌîå Îç∞Ïù¥ÌÑ∞
    const users = [
      { id: 1, name: 'ÍπÄÏ≤†Ïàò', email: 'kim@example.com' },
      { id: 2, name: 'Ïù¥ÏòÅÌù¨', email: 'lee@example.com' }
    ];

    // Express ÏùëÎãµÏóê Ïì∞Îäî WritableStream ÏÉùÏÑ±
    const writableStream = new WritableStream<Uint8Array>({
      write(chunk) {
        res.write(chunk);
      },
      close() {
        res.end();
      }
    });

    const writer = new StaxXmlWriter(writableStream, {
      prettyPrint: true,
      indentString: '  '
    });

    // Ï†ÅÏ†àÌïú Ìó§Îçî ÏÑ§Ï†ï
    res.setHeader('Content-Type', 'application/xml; charset=utf-8');
    res.setHeader('Cache-Control', 'no-cache');

    // XML ÏûëÏÑ±
    await writer.writeStartDocument('1.0', 'utf-8');
    await writer.writeStartElement('users');
    
    for (const user of users) {
      await writer.writeStartElement('user', { attributes: { id: user.id.toString() } });
      
      await writer.writeStartElement('name');
      await writer.writeCharacters(user.name);
      await writer.writeEndElement();
      
      await writer.writeStartElement('email');
      await writer.writeCharacters(user.email);
      await writer.writeEndElement();
      
      await writer.writeEndElement(); // user
    }
    
    await writer.writeEndElement(); // users
    await writer.writeEndDocument();
    
  } catch (error) {
    res.status(500).json({ error: 'XML ÏÉùÏÑ±Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§' });
  }
});

app.listen(3000, () => {
  console.log('ÏÑúÎ≤ÑÍ∞Ä Ìè¨Ìä∏ 3000ÏóêÏÑú Ïã§Ìñâ Ï§ëÏûÖÎãàÎã§');
});
```

##### Hono ÌîÑÎ†àÏûÑÏõåÌÅ¨ - Ïä§Ìä∏Î¶¨Î∞ç XML ÏùëÎãµ

```typescript
import { Hono } from 'hono';
import { StaxXmlWriter } from 'stax-xml';

const app = new Hono();

app.get('/api/products', async (c) => {
  // ÏÉòÌîå Ï†úÌíà Îç∞Ïù¥ÌÑ∞
  const products = [
    { id: 'P001', name: 'Ïä§ÎßàÌä∏Ìè∞', price: 899000, category: 'Ï†ÑÏûêÍ∏∞Í∏∞' },
    { id: 'P002', name: 'Ìó§ÎìúÌè∞', price: 259000, category: 'Ï†ÑÏûêÍ∏∞Í∏∞' },
    { id: 'P003', name: 'Ïª§ÌîºÎ©îÏù¥Ïª§', price: 189000, category: 'Í∞ÄÏ†ÑÏ†úÌíà' }
  ];

  // Ïä§Ìä∏Î¶¨Î∞ç ÏùëÎãµÏö© ReadableStream ÏÉùÏÑ±
  const readable = new ReadableStream<Uint8Array>({
    async start(controller) {
      // Ïª®Ìä∏Î°§Îü¨Ïóê Îç∞Ïù¥ÌÑ∞Î•º ÌÅêÏûâÌïòÎäî WritableStream ÏÉùÏÑ±
      const writableStream = new WritableStream<Uint8Array>({
        write(chunk) {
          controller.enqueue(chunk);
        },
        close() {
          controller.close();
        },
        abort(reason) {
          controller.error(reason);
        }
      });

      const writer = new StaxXmlWriter(writableStream, {
        prettyPrint: true,
        indentString: '    '
      });

      try {
        // XML ÏÉùÏÑ±
        await writer.writeStartDocument('1.0', 'utf-8');
        await writer.writeStartElement('products', {
          attributes: {
            count: products.length.toString(),
            generated: new Date().toISOString()
          }
        });
        
        for (const product of products) {
          await writer.writeStartElement('product', {
            attributes: {
              id: product.id,
              category: product.category
            }
          });
          
          await writer.writeStartElement('name');
          await writer.writeCharacters(product.name);
          await writer.writeEndElement();
          
          await writer.writeStartElement('price', { attributes: { currency: 'KRW' } });
          await writer.writeCharacters(product.price.toString());
          await writer.writeEndElement();
          
          await writer.writeEndElement(); // product
        }
        
        await writer.writeEndElement(); // products
        await writer.writeEndDocument();
        
      } catch (error) {
        controller.error(error);
      }
    }
  });

  return new Response(readable, {
    headers: {
      'Content-Type': 'application/xml; charset=utf-8',
      'Cache-Control': 'no-cache',
      'Transfer-Encoding': 'chunked'
    }
  });
});

export default app;
```

##### Í≥†Í∏â Writer Í∏∞Îä•

```typescript
import { StaxXmlWriter } from 'stax-xml';

// ÏÇ¨Ïö©Ïûê Ï†ïÏùò ÏóîÌã∞Ìã∞ÏôÄ ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§Î•º ÏÇ¨Ïö©Ìïú Î©îÎ™®Î¶¨ ÎÇ¥ XML ÏÉùÏÑ±
async function createAdvancedXml() {
  let xmlOutput = '';
  
  const writableStream = new WritableStream<Uint8Array>({
    write(chunk) {
      xmlOutput += new TextDecoder().decode(chunk);
    }
  });

  const writer = new StaxXmlWriter(writableStream, {
    prettyPrint: true,
    indentString: '  ',
    addEntities: [
      { entity: 'company', value: 'ÏïÑÌÅ¨Î©î ÏΩîÌçºÎ†àÏù¥ÏÖò' },
      { entity: 'copyright', value: '¬© 2024' }
    ],
    autoEncodeEntities: true
  });

  // ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ÏôÄ ÏÇ¨Ïö©Ïûê Ï†ïÏùò ÏóîÌã∞Ìã∞Í∞Ä Ìè¨Ìï®Îêú XML ÏûëÏÑ±
  await writer.writeStartDocument('1.0', 'utf-8');
  
  await writer.writeStartElement('document', { 
    prefix: 'doc', 
    uri: 'http://example.com/document', 
    attributes: { version: '2.0' } 
  });
  await writer.writeNamespace('meta', 'http://example.com/metadata');
  
  await writer.writeStartElement('header', { prefix: 'meta' });
  await writer.writeStartElement('title');
  await writer.writeCharacters('Ï†úÌíà Ïπ¥ÌÉàÎ°úÍ∑∏');
  await writer.writeEndElement();
  
  await writer.writeStartElement('company');
  await writer.writeCharacters('&company;'); // ÏûêÎèôÏúºÎ°ú Ïù∏ÏΩîÎî©Îê©ÎãàÎã§
  await writer.writeEndElement();
  await writer.writeEndElement(); // header
  
  await writer.writeStartElement('content');
  await writer.writeStartElement('item', { attributes: { type: 'featured' } });
  
  // Self-closing ÏöîÏÜå
  await writer.writeStartElement('thumbnail', {
    attributes: {
      src: 'image.jpg',
      alt: 'Ï†úÌíà Ïù¥ÎØ∏ÏßÄ'
    },
    selfClosing: true
  });
  
  await writer.writeStartElement('description');
  await writer.writeCDATA('<p>Ïù¥Í≤ÉÏùÄ CDATA ÎÇ¥Ïùò <b>HTML</b> ÏΩòÌÖêÏ∏†ÏûÖÎãàÎã§</p>');
  await writer.writeEndElement();
  
  await writer.writeEndElement(); // item
  await writer.writeEndElement(); // content
  await writer.writeEndElement(); // document
  
  await writer.writeEndDocument();
  
  return xmlOutput;
}

// ÏÇ¨Ïö©Î≤ï
createAdvancedXml().then(xml => {
  console.log('ÏÉùÏÑ±Îêú XML:', xml);
});
```

##### ÏÉàÎ°úÏö¥ ÌÜµÌï© WriteElementOptions API

StaxXmlWriterÎäî Ïù¥Ï†ú Î™®Îì† ÏòµÏÖòÏùÑ Îã®Ïùº `WriteElementOptions` Í∞ùÏ≤¥Î°ú ÌÜµÌï©ÌïòÏó¨ ÏöîÏÜå ÏÉùÏÑ±ÏùÑ Îã®ÏàúÌôîÌïòÎäî ÏÉàÎ°úÏö¥ ÌÜµÌï© APIÎ•º ÏßÄÏõêÌï©ÎãàÎã§:

```typescript
import { StaxXmlWriter, WriteElementOptions } from 'stax-xml';

async function createXmlWithNewAPI() {
  let xmlOutput = '';
  
  const writableStream = new WritableStream<Uint8Array>({
    write(chunk) {
      xmlOutput += new TextDecoder().decode(chunk);
    }
  });

  const writer = new StaxXmlWriter(writableStream, { prettyPrint: true });

  await writer.writeStartDocument();
  
  // ÏÜçÏÑ±Ïù¥ ÏûàÎäî Í∏∞Î≥∏ ÏöîÏÜå
  await writer.writeStartElement('catalog', {
    attributes: { version: '2.0', xmlns: 'http://example.com/catalog' }
  });
  
  // ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ÏôÄ ÏÜçÏÑ±Ïù¥ ÏûàÎäî ÏöîÏÜå
  await writer.writeStartElement('product', {
    prefix: 'cat',
    uri: 'http://example.com/catalog',
    attributes: { id: '001', featured: 'true' }
  });
  
  await writer.writeStartElement('name');
  await writer.writeCharacters('ÌîÑÎ¶¨ÎØ∏ÏóÑ ÎÖ∏Ìä∏Î∂Å');
  await writer.writeEndElement();
  
  // ÏÜçÏÑ±Ïù¥ ÏûàÎäî self-closing ÏöîÏÜå
  await writer.writeStartElement('thumbnail', {
    attributes: {
      src: 'image.jpg',
      alt: 'Ï†úÌíà Ïù¥ÎØ∏ÏßÄ',
      width: '200'
    },
    selfClosing: true  // writeEndElement() Ìò∏Ï∂ú Î∂àÌïÑÏöî
  });
  
  // Í∞ÑÎã®Ìïú self-closing ÏöîÏÜå
  await writer.writeStartElement('br', { selfClosing: true });
  
  await writer.writeEndElement(); // product
  await writer.writeEndElement(); // catalog
  
  await writer.writeEndDocument();
  return xmlOutput;
}

// Ï∂úÎ†•:
// <?xml version="1.0" encoding="UTF-8"?>
// <catalog version="2.0" xmlns="http://example.com/catalog">
//   <cat:product id="001" featured="true" xmlns:cat="http://example.com/catalog">
//     <name>ÌîÑÎ¶¨ÎØ∏ÏóÑ ÎÖ∏Ìä∏Î∂Å</name>
//     <thumbnail src="image.jpg" alt="Ï†úÌíà Ïù¥ÎØ∏ÏßÄ" width="200"/>
//     <br/>
//   </cat:product>
// </catalog>
```

**ÏÉàÎ°úÏö¥ APIÏùò Ï£ºÏöî Ïû•Ï†ê:**

- **ÌÜµÌï©Îêú ÌååÎùºÎØ∏ÌÑ∞**: Î™®Îì† ÏöîÏÜå ÏòµÏÖò(ÏÜçÏÑ±, ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§, self-closing)Ïù¥ Îã®Ïùº ÏòµÏÖò Í∞ùÏ≤¥Î°ú ÌÜµÌï©
- **Self-Closing ÏßÄÏõê**: `selfClosing: true`Î°ú ÏÑ§Ï†ïÌïòÎ©¥ `writeEndElement()` Ìò∏Ï∂ú ÏóÜÏù¥ ÏûêÎèôÏúºÎ°ú ÏöîÏÜåÍ∞Ä Îã´Ìûò
- **Îçî ÍπîÎÅîÌïú Î¨∏Î≤ï**: Îçî ÏßÅÍ¥ÄÏ†ÅÏù¥Í≥† ÏùΩÍ∏∞ Ïâ¨Ïö¥ ÏΩîÎìú Íµ¨Ï°∞
- **ÌÉÄÏûÖ ÏïàÏ†ÑÏÑ±**: Ìè¨Í¥ÑÏ†ÅÏù∏ ÌÉÄÏûÖ Ï†ïÏùòÎ°ú ÏôÑÏ†ÑÌïú TypeScript ÏßÄÏõê

**ÏÇ¨Ïö© ÏòàÏ†ú:**

```typescript
// ÏÜçÏÑ±Ïù¥ ÏûàÎäî Í∞ÑÎã®Ìïú ÏöîÏÜå
await writer.writeStartElement('img', {
  attributes: {
    src: 'image.jpg',
    alt: 'Ïù¥ÎØ∏ÏßÄ'
  },
  selfClosing: true
});

// ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§Í∞Ä ÏûàÎäî ÏöîÏÜå
await writer.writeStartElement('title', {
  prefix: 'html',
  uri: 'http://www.w3.org/1999/xhtml',
  attributes: { lang: 'ko' }
});
```

#### Custom Entity Support

```typescript
const parser = new StaxXmlParser(stream, {
  addEntities: [
    { entity: 'custom', value: 'ÏÇ¨Ïö©Ïûê Ï†ïÏùò Í∞í' },
    { entity: 'special', value: '‚òÖ' }
  ]
});
```

#### Large File Processing

```typescript
// ÎåÄÏö©Îüâ XML ÌååÏùºÏùò Ìö®Ïú®Ï†Å Ï≤òÎ¶¨
const parser = new StaxXmlParser(largeXmlStream, {
  maxBufferSize: 128 * 1024, // 128KB Î≤ÑÌçº
  enableBufferCompaction: true
});

// Ï†ÑÏ≤¥ ÌååÏùºÏùÑ Î©îÎ™®Î¶¨Ïóê Î°úÎìúÌïòÏßÄ ÏïäÍ≥† Ïù¥Î≤§Ìä∏Î•º ÏàúÏ∞®Ï†ÅÏúºÎ°ú Ï≤òÎ¶¨
for await (const event of parser) {
  // Í∞Å Ïù¥Î≤§Ìä∏Î•º Í∞úÎ≥ÑÏ†ÅÏúºÎ°ú Ï≤òÎ¶¨
  processEvent(event);
}
```

#### Namespace Handling

```typescript
// ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§Í∞Ä ÏûàÎäî XML
const xmlWithNamespaces = `
  <root xmlns:ns="http://example.com/namespace">
    <ns:element>ÎÇ¥Ïö©</ns:element>
  </root>
`;

for await (const event of parser) {
  if (event.type === XmlEventType.START_ELEMENT) {
    console.log('ÏöîÏÜåÎ™Ö:', event.name);
    console.log('Î°úÏª¨Î™Ö:', event.localName);
    console.log('ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ URI:', event.uri);
    console.log('Ï†ëÎëêÏÇ¨:', event.prefix);
  }
}
```

### üéØ Event Types

- `START_DOCUMENT`: XML Î¨∏ÏÑú ÏãúÏûë
- `END_DOCUMENT`: XML Î¨∏ÏÑú ÎÅù
- `START_ELEMENT`: XML ÏãúÏûë ÌÉúÍ∑∏
- `END_ELEMENT`: XML ÎÅù ÌÉúÍ∑∏
- `CHARACTERS`: ÌÉúÍ∑∏ ÏÇ¨Ïù¥Ïùò ÌÖçÏä§Ìä∏ ÎÇ¥Ïö©
- `CDATA`: CDATA ÏÑπÏÖò ÎÇ¥Ïö©
- `ERROR`: ÌååÏã± Ïò§Î•ò Î∞úÏÉù

### üìö API Reference

#### StaxXmlParser

```typescript
class StaxXmlParser {
  constructor(
    xmlStream: ReadableStream<Uint8Array>,
    options?: StaxXmlParserOptions
  )
}

interface StaxXmlParserOptions {
  encoding?: string; // Í∏∞Î≥∏Í∞í: 'utf-8'
  addEntities?: { entity: string, value: string }[];
  autoDecodeEntities?: boolean; // Í∏∞Î≥∏Í∞í: true
  maxBufferSize?: number; // Í∏∞Î≥∏Í∞í: 64KB
  enableBufferCompaction?: boolean; // Í∏∞Î≥∏Í∞í: true
}
```

#### StaxXmlParserSync

```typescript
class StaxXmlParserSync {
  constructor(
    xmlString: string,
    options?: StaxXmlParserSyncOptions
  )
}

interface StaxXmlParserSyncOptions {
  autoDecodeEntities?: boolean; // Í∏∞Î≥∏Í∞í: true
  addEntities?: { entity: string, value: string }[];
}
```

#### StaxXmlWriter

```typescript
interface WriteElementOptions {
  prefix?: string;              // ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ Ï†ëÎëêÏÇ¨
  uri?: string;                 // ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ URI
  attributes?: Record<string, string>; // ÏöîÏÜå ÏÜçÏÑ±
  selfClosing?: boolean;        // self-closing ÌÉúÍ∑∏ Ïó¨Î∂Ä
}

class StaxXmlWriter {
  constructor(
    outputStream: WritableStream<Uint8Array>,
    options?: StaxXmlWriterOptions
  )

  // Î¨∏ÏÑú Î†àÎ≤® Î©îÏÑúÎìú
  writeStartDocument(version?: string, encoding?: string): this
  writeEndDocument(): Promise<void>

  // ÏöîÏÜå ÏûëÏÑ± Î©îÏÑúÎìú
  writeStartElement(localName: string, options?: WriteElementOptions): this
  writeEndElement(): this

  // ÏÜçÏÑ± Î∞è ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ Î©îÏÑúÎìú
  writeAttribute(localName: string, value: string, prefix?: string, uri?: string): this
  writeNamespace(prefix: string, uri: string): this

  // ÏΩòÌÖêÏ∏† ÏûëÏÑ± Î©îÏÑúÎìú
  writeCharacters(text: string): this
  writeCDATA(cdata: string): this
  writeComment(comment: string): this
  writeProcessingInstruction(target: string, data?: string): this

  // Ïú†Ìã∏Î¶¨Ìã∞ Î©îÏÑúÎìú
  setPrettyPrint(enabled: boolean): this
  setIndentString(indentString: string): this
  isPrettyPrintEnabled(): boolean
  getIndentString(): string
}

interface StaxXmlWriterOptions {
  encoding?: string; // Í∏∞Î≥∏Í∞í: 'utf-8'
  prettyPrint?: boolean; // Í∏∞Î≥∏Í∞í: false
  indentString?: string; // Í∏∞Î≥∏Í∞í: '  '
  addEntities?: { entity: string, value: string }[];
  autoEncodeEntities?: boolean; // Í∏∞Î≥∏Í∞í: true
  namespaces?: NamespaceDeclaration[];
}

interface XmlAttribute {
  localName: string;
  value: string;
  prefix?: string;
  uri?: string;
}

interface NamespaceDeclaration {
  prefix?: string;
  uri: string;
}
```

### üß™ Testing

```bash
bun test
```

### üìÅ Sample File Sources

Sources of sample XML files used in testing:

- `books.xml`: [Microsoft XML Document Examples](https://learn.microsoft.com/en-us/previous-versions/windows/desktop/ms762271(v=vs.85))
- `simple-namespace.xml`: [W3Schools XML Namespaces Guide](https://www.w3schools.com/xml/xml_namespaces.asp)
- `treebank_e.xml`: [University of Washington XML Data Repository](https://aiweb.cs.washington.edu/research/projects/xmltk/xmldata/www/repository.html)

### üìÑ License

MIT

### ü§ù Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

---

## Korean

JavaÏùò StAX(Streaming API for XML)ÏóêÏÑú ÏòÅÍ∞êÏùÑ Î∞õÏùÄ Í≥†ÏÑ±Îä• pull Î∞©ÏãùÏùò JavaScript/TypeScript XML ÌååÏÑúÏûÖÎãàÎã§. **ÎåÄÏö©Îüâ ÌååÏùºÏùÑ ÏúÑÌïú ÏôÑÏ†Ñ ÎπÑÎèôÍ∏∞ Ïä§Ìä∏Î¶º Í∏∞Î∞ò ÌååÏã±**Í≥º **ÏûëÏùÄ Ïù∏Î©îÎ™®Î¶¨ XML Î¨∏ÏÑúÎ•º ÏúÑÌïú ÎèôÍ∏∞ ÌååÏã±**ÏùÑ Î™®Îëê Ï†úÍ≥µÌï©ÎãàÎã§. Í∏∞Ï°¥Ïùò XML-JSON Îß§ÌçºÏôÄ Îã¨Î¶¨, StAX-XMLÏùÑ ÏÇ¨Ïö©ÌïòÎ©¥ XML Îç∞Ïù¥ÌÑ∞Î•º ÏõêÌïòÎäî ÏûÑÏùòÏùò Íµ¨Ï°∞Î°ú Îß§ÌïëÌï† Ïàò ÏûàÏúºÎ©∞, Ïä§Ìä∏Î¶¨Î∞ç ÎòêÎäî ÏßÅÏ†ë Î¨∏ÏûêÏó¥ Ï≤òÎ¶¨Î•º ÌÜµÌï¥ XML ÌååÏùºÏùÑ Ìö®Ïú®Ï†ÅÏúºÎ°ú Ï≤òÎ¶¨Ìï† Ïàò ÏûàÏäµÎãàÎã§.

### üöÄ Ï£ºÏöî Í∏∞Îä•

- **ÏôÑÏ†Ñ ÎπÑÎèôÍ∏∞ (Ïä§Ìä∏Î¶º Í∏∞Î∞ò)**: ÎåÄÏö©Îüâ XML ÌååÏùºÏùò Î©îÎ™®Î¶¨ Ìö®Ïú®Ï†Å Ï≤òÎ¶¨Î•º ÏúÑÌïú Ïä§Ìä∏Î¶º Í∏∞Î∞ò Ï†ëÍ∑º
- **ÎèôÍ∏∞ (Î¨∏ÏûêÏó¥ Í∏∞Î∞ò)**: ÏûëÏùÄ Ïù∏Î©îÎ™®Î¶¨ XML Î¨∏ÏûêÏó¥Ïùò Í≥†ÏÑ±Îä• ÌååÏã±ÏùÑ ÏúÑÌïú ÏßÅÏ†ë Î¨∏ÏûêÏó¥ Ï≤òÎ¶¨
- **Pull Î∞©Ïãù ÌååÏã±**: ÎåÄÏö©Îüâ XML ÌååÏùºÏùò Î©îÎ™®Î¶¨ Ìö®Ïú®Ï†Å Ï≤òÎ¶¨Î•º ÏúÑÌïú Ïä§Ìä∏Î¶º Í∏∞Î∞ò Ï†ëÍ∑º
- **ÏÇ¨Ïö©Ïûê Ï†ïÏùò Îß§Ìïë**: Îã®ÏàúÌïú JSON Í∞ùÏ≤¥Í∞Ä ÏïÑÎãå ÏõêÌïòÎäî Íµ¨Ï°∞Î°ú XML Îç∞Ïù¥ÌÑ∞ Îß§Ìïë Í∞ÄÎä•
- **Í≥†ÏÑ±Îä•**: ÏÜçÎèÑÏôÄ ÎÇÆÏùÄ Î©îÎ™®Î¶¨ ÏÇ¨Ïö©ÎüâÏóê ÏµúÏ†ÅÌôî
- **Î≤îÏö© Ìò∏ÌôòÏÑ±**: Ïõπ ÌëúÏ§Ä APIÎßå ÏÇ¨Ïö©ÌïòÏó¨ Node.js, Bun, Deno, Ïõπ Î∏åÎùºÏö∞Ï†ÄÏóêÏÑú Î™®Îëê ÎèôÏûë
- **ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ ÏßÄÏõê**: Í∏∞Î≥∏Ï†ÅÏù∏ XML ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ Ï≤òÎ¶¨
- **ÏóîÌã∞Ìã∞ ÏßÄÏõê**: ÎÇ¥Ïû• ÏóîÌã∞Ìã∞ ÎîîÏΩîÎî© Î∞è ÏÇ¨Ïö©Ïûê Ï†ïÏùò ÏóîÌã∞Ìã∞ ÏßÄÏõê
- **TypeScript ÏßÄÏõê**: Ìè¨Í¥ÑÏ†ÅÏù∏ ÌÉÄÏûÖ Ï†ïÏùòÎ°ú ÏôÑÏ†ÑÌïú TypeScript ÏßÄÏõê

### üì¶ ÏÑ§Ïπò

```bash
# npm
npm install stax-xml
# yarn
yarn add stax-xml
# pnpm
pnpm add stax-xml
# bun
bun add stax-xml
# deno
deno add npm:stax-xml
```

### üîß Îπ†Î•∏ ÏãúÏûë

#### XML Î¨∏ÏûêÏó¥ ÌååÏã± (ÎπÑÎèôÍ∏∞ - StaxXmlParser)

```typescript
import { StaxXmlParser, XmlEventType } from 'stax-xml';

// XML Î¨∏ÏûêÏó¥Î°úÎ∂ÄÌÑ∞ ReadableStream ÏÉùÏÑ±
const xmlContent = `
  <books>
    <book id="1">
      <title>ÏúÑÎåÄÌïú Í∞úÏ∏†ÎπÑ</title>
      <author>F. Ïä§ÏΩß ÌîºÏ∏†Ï†úÎü¥Îìú</author>
    </book>
    <book id="2">
      <title>ÏïµÎ¨¥ÏÉà Ï£ΩÏù¥Í∏∞</title>
      <author>ÌïòÌçº Î¶¨</author>
    </book>
  </books>
`;

const stream = new ReadableStream({
  start(controller) {
    controller.enqueue(new TextEncoder().encode(xmlContent));
    controller.close();
  }
});

// Pull Î∞©ÏãùÏúºÎ°ú XML ÌååÏã±
const parser = new StaxXmlParser(stream);
const books = [];
let currentBook = null;
let currentText = '';

for await (const event of parser) {
  switch (event.type) {
    case XmlEventType.START_ELEMENT:
      if (event.name === 'book') {
        currentBook = { id: event.attributes?.id || '', title: '', author: '' };
      }
      currentText = '';
      break;
      
    case XmlEventType.CHARACTERS:
      currentText += event.data;
      break;
      
    case XmlEventType.END_ELEMENT:
      if (currentBook) {
        if (event.name === 'title') {
          currentBook.title = currentText.trim();
        } else if (event.name === 'author') {
          currentBook.author = currentText.trim();
        } else if (event.name === 'book') {
          books.push(currentBook);
          currentBook = null;
        }
      }
      break;
  }
}

console.log(books);
// Ï∂úÎ†•: [
//   { id: "1", title: "ÏúÑÎåÄÌïú Í∞úÏ∏†ÎπÑ", author: "F. Ïä§ÏΩß ÌîºÏ∏†Ï†úÎü¥Îìú" },
//   { id: "2", title: "ÏïµÎ¨¥ÏÉà Ï£ΩÏù¥Í∏∞", author: "ÌïòÌçº Î¶¨" }
// ]
```

#### XML Î¨∏ÏûêÏó¥ ÌååÏã± (ÎèôÍ∏∞ - StaxXmlParserSync)

```typescript
import { StaxXmlParserSync, XmlEventType } from 'stax-xml';

const xmlContent = `
  <catalog>
    <product id="P001">
      <name>ÎÖ∏Ìä∏Î∂Å</name>
      <price>1200</price>
    </product>
    <product id="P002">
      <name>ÎßàÏö∞Ïä§</name>
      <price>25</price>
    </product>
  </catalog>
`;

const parser = new StaxXmlParserSync(xmlContent);
const products = [];
let currentProduct = null;
let currentText = '';

for (const event of parser) { // ÎèôÍ∏∞ Î∞òÎ≥µÏùÑ ÏúÑÌï¥ for...of ÏÇ¨Ïö©
  switch (event.type) {
    case XmlEventType.START_ELEMENT:
      if (event.name === 'product') {
        currentProduct = { id: event.attributes?.id || '', name: '', price: 0 };
      } else if (event.name === 'name' || event.name === 'price') {
        currentText = ''; // ÏÉà ÏöîÏÜåÎ•º ÏúÑÌï¥ ÌÖçÏä§Ìä∏ Î≤ÑÌçº Ï¥àÍ∏∞Ìôî
      }
      break;
      
    case XmlEventType.CHARACTERS:
      currentText += event.value; // ÎèôÍ∏∞ ÌååÏÑúÏùò Í≤ΩÏö∞ event.value ÏÇ¨Ïö©
      break;
      
    case XmlEventType.END_ELEMENT:
      if (currentProduct) {
        if (event.name === 'name') {
          currentProduct.name = currentText.trim();
        } else if (event.name === 'price') {
          currentProduct.price = parseFloat(currentText.trim());
        } else if (event.name === 'product') {
          products.push(currentProduct);
          currentProduct = null;
        }
      }
      break;
  }
}

console.log(products);
// Ï∂úÎ†•: [
//   { id: "P001", name: "ÎÖ∏Ìä∏Î∂Å", price: 1200 },
//   { id: "P002", name: "ÎßàÏö∞Ïä§", price: 25 }
// ]
```

#### FetchÎ°ú ÏõêÍ≤© XML ÌååÏã±

```typescript
import { StaxXmlParser, XmlEventType } from 'stax-xml';

async function parseRemoteXml(url: string) {
  try {
    // ÏõêÍ≤© URLÏóêÏÑú XML Í∞ÄÏ†∏Ïò§Í∏∞
    const response = await fetch(url);
    
    if (!response.ok) {
      throw new Error(`HTTP Ïò§Î•ò! ÏÉÅÌÉú: ${response.status}`);
    }
    
    // ÏùëÎãµ Î≥∏Î¨∏ÏùÑ ReadableStreamÏúºÎ°ú Í∞ÄÏ†∏Ïò§Í∏∞
    const xmlStream = response.body;
    
    if (!xmlStream) {
      throw new Error('ÏùëÎãµ Î≥∏Î¨∏Ïù¥ ÏóÜÏäµÎãàÎã§');
    }
    
    // XML Ïä§Ìä∏Î¶ºÏùÑ ÏßÅÏ†ë ÌååÏã±
    const parser = new StaxXmlParser(xmlStream);
    const results = [];
    let currentItem = {};
    let currentText = '';
    
    for await (const event of parser) {
      switch (event.type) {
        case XmlEventType.START_ELEMENT:
          if (event.name === 'item') {
            currentItem = {};
          }
          currentText = '';
          break;
          
        case XmlEventType.CHARACTERS:
          currentText += event.data;
          break;
          
        case XmlEventType.END_ELEMENT:
          if (event.name === 'title' || event.name === 'description') {
            currentItem[event.name] = currentText.trim();
          } else if (event.name === 'item') {
            results.push(currentItem);
          }
          break;
      }
    }
    
    return results;
  } catch (error) {
    console.error('ÏõêÍ≤© XML ÌååÏã± Ïò§Î•ò:', error);
    throw error;
  }
}

// ÏÇ¨Ïö© ÏòàÏ†ú
const rssUrl = 'https://example.com/feed.xml';
const xmlApiUrl = 'https://api.example.com/data.xml';

// RSS ÌîºÎìú ÌååÏã±
parseRemoteXml(rssUrl)
  .then(items => {
    console.log('RSS Ìï≠Î™©:', items);
  })
  .catch(error => {
    console.error('RSS ÌååÏã± Ïã§Ìå®:', error);
  });

// API ÏùëÎãµ ÌååÏã±
parseRemoteXml(xmlApiUrl)
  .then(data => {
    console.log('API Îç∞Ïù¥ÌÑ∞:', data);
  })
  .catch(error => {
    console.error('API ÏùëÎãµ ÌååÏã± Ïã§Ìå®:', error);
  });
```

### üåê ÌîåÎû´Ìèº Ìò∏ÌôòÏÑ±

StAX-XMLÏùÄ Ïõπ ÌëúÏ§Ä APIÎßåÏùÑ ÏÇ¨Ïö©ÌïòÏó¨ Îã§Ïùå ÌôòÍ≤ΩÏóêÏÑú ÎèôÏûëÌï©ÎãàÎã§:

- **Node.js** (v18+)
- **Bun** (Î™®Îì† Î≤ÑÏ†Ñ)
- **Deno** (Î™®Îì† Î≤ÑÏ†Ñ)
- **Ïõπ Î∏åÎùºÏö∞Ï†Ä** (ÏµúÏã† Î∏åÎùºÏö∞Ï†Ä)
- **Edge Runtime** (Vercel, Cloudflare Workers Îì±)

### ‚ö° Í≥†Í∏â ÏÇ¨Ïö©Î≤ï

#### StaxXmlWriter - XML Î¨∏ÏÑú ÏÉùÏÑ±

StAX-XMLÏùÄ ÌîÑÎ°úÍ∑∏ÎûòÎ∞ç Î∞©ÏãùÏúºÎ°ú XML Î¨∏ÏÑúÎ•º ÏÉùÏÑ±Ìï† Ïàò ÏûàÎäî Í∞ïÎ†•Ìïú XML ÏûëÏÑ±Í∏∞ÎèÑ Ìè¨Ìï®ÌïòÍ≥† ÏûàÏäµÎãàÎã§.

##### Î°úÏª¨ ÌååÏùº ÏÉùÏÑ±

```typescript
import { StaxXmlWriter } from 'stax-xml';
import { createWriteStream } from 'fs';

// Node.jsÏö© - fsÏóêÏÑú WritableStream ÏÉùÏÑ±
async function createLocalXmlFile() {
  const fileStream = createWriteStream('./output.xml');
  
  // Node.js WriteStreamÏùÑ Ïõπ ÌëúÏ§Ä WritableStreamÏúºÎ°ú Î≥ÄÌôò
  const writableStream = new WritableStream<Uint8Array>({
    write(chunk) {
      fileStream.write(chunk);
    },
    close() {
      fileStream.end();
    }
  });

  const writer = new StaxXmlWriter(writableStream, {
    prettyPrint: true,
    indentString: '  '
  });

  // XML Î¨∏ÏÑú ÏûëÏÑ±
  await writer.writeStartDocument('1.0', 'utf-8');
  
  await writer.writeStartElement('catalog', { attributes: { version: '1.0' } });
  
  await writer.writeStartElement('product', { attributes: { id: '001' } });
  
  await writer.writeStartElement('name');
  await writer.writeCharacters('ÎÖ∏Ìä∏Î∂Å Ïª¥Ìì®ÌÑ∞');
  await writer.writeEndElement();
  
  await writer.writeStartElement('price', { attributes: { currency: 'KRW' } });
  await writer.writeCharacters('1299000');
  await writer.writeEndElement();
  
  await writer.writeEndElement(); // product
  await writer.writeEndElement(); // catalog
  
  await writer.writeEndDocument();
  console.log('XML ÌååÏùºÏù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§!');
}

createLocalXmlFile();
```

##### Express.js ÎØ∏Îì§Ïõ®Ïñ¥ - XML ÏùëÎãµ

```typescript
import express from 'express';
import { StaxXmlWriter } from 'stax-xml';

const app = express();

// XML ÏùëÎãµÏùÑ ÏÉùÏÑ±ÌïòÎäî ÎØ∏Îì§Ïõ®Ïñ¥
app.get('/api/users', async (req, res) => {
  try {
    // ÏÉòÌîå Îç∞Ïù¥ÌÑ∞
    const users = [
      { id: 1, name: 'ÍπÄÏ≤†Ïàò', email: 'kim@example.com' },
      { id: 2, name: 'Ïù¥ÏòÅÌù¨', email: 'lee@example.com' }
    ];

    // Express ÏùëÎãµÏóê Ïì∞Îäî WritableStream ÏÉùÏÑ±
    const writableStream = new WritableStream<Uint8Array>({
      write(chunk) {
        res.write(chunk);
      },
      close() {
        res.end();
      }
    });

    const writer = new StaxXmlWriter(writableStream, {
      prettyPrint: true,
      indentString: '  '
    });

    // Ï†ÅÏ†àÌïú Ìó§Îçî ÏÑ§Ï†ï
    res.setHeader('Content-Type', 'application/xml; charset=utf-8');
    res.setHeader('Cache-Control', 'no-cache');

    // XML ÏûëÏÑ±
    await writer.writeStartDocument('1.0', 'utf-8');
    await writer.writeStartElement('users');
    
    for (const user of users) {
      await writer.writeStartElement('user', { attributes: { id: user.id.toString() } });
      
      await writer.writeStartElement('name');
      await writer.writeCharacters(user.name);
      await writer.writeEndElement();
      
      await writer.writeStartElement('email');
      await writer.writeCharacters(user.email);
      await writer.writeEndElement();
      
      await writer.writeEndElement(); // user
    }
    
    await writer.writeEndElement(); // users
    await writer.writeEndDocument();
    
  } catch (error) {
    res.status(500).json({ error: 'XML ÏÉùÏÑ±Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§' });
  }
});

app.listen(3000, () => {
  console.log('ÏÑúÎ≤ÑÍ∞Ä Ìè¨Ìä∏ 3000ÏóêÏÑú Ïã§Ìñâ Ï§ëÏûÖÎãàÎã§');
});
```

##### Hono ÌîÑÎ†àÏûÑÏõåÌÅ¨ - Ïä§Ìä∏Î¶¨Î∞ç XML ÏùëÎãµ

```typescript
import { Hono } from 'hono';
import { StaxXmlWriter } from 'stax-xml';

const app = new Hono();

app.get('/api/products', async (c) => {
  // ÏÉòÌîå Ï†úÌíà Îç∞Ïù¥ÌÑ∞
  const products = [
    { id: 'P001', name: 'Ïä§ÎßàÌä∏Ìè∞', price: 899000, category: 'Ï†ÑÏûêÍ∏∞Í∏∞' },
    { id: 'P002', name: 'Ìó§ÎìúÌè∞', price: 259000, category: 'Ï†ÑÏûêÍ∏∞Í∏∞' },
    { id: 'P003', name: 'Ïª§ÌîºÎ©îÏù¥Ïª§', price: 189000, category: 'Í∞ÄÏ†ÑÏ†úÌíà' }
  ];

  // Ïä§Ìä∏Î¶¨Î∞ç ÏùëÎãµÏö© ReadableStream ÏÉùÏÑ±
  const readable = new ReadableStream<Uint8Array>({
    async start(controller) {
      // Ïª®Ìä∏Î°§Îü¨Ïóê Îç∞Ïù¥ÌÑ∞Î•º ÌÅêÏûâÌïòÎäî WritableStream ÏÉùÏÑ±
      const writableStream = new WritableStream<Uint8Array>({
        write(chunk) {
          controller.enqueue(chunk);
        },
        close() {
          controller.close();
        },
        abort(reason) {
          controller.error(reason);
        }
      });

      const writer = new StaxXmlWriter(writableStream, {
        prettyPrint: true,
        indentString: '    '
      });

      try {
        // XML ÏÉùÏÑ±
        await writer.writeStartDocument('1.0', 'utf-8');
        await writer.writeStartElement('products', {
          attributes: {
            count: products.length.toString(),
            generated: new Date().toISOString()
          }
        });
        
        for (const product of products) {
          await writer.writeStartElement('product', {
            attributes: {
              id: product.id,
              category: product.category
            }
          });
          
          await writer.writeStartElement('name');
          await writer.writeCharacters(product.name);
          await writer.writeEndElement();
          
          await writer.writeStartElement('price', { attributes: { currency: 'KRW' } });
          await writer.writeCharacters(product.price.toString());
          await writer.writeEndElement();
          
          await writer.writeEndElement(); // product
        }
        
        await writer.writeEndElement(); // products
        await writer.writeEndDocument();
        
      } catch (error) {
        controller.error(error);
      }
    }
  });

  return new Response(readable, {
    headers: {
      'Content-Type': 'application/xml; charset=utf-8',
      'Cache-Control', 'no-cache',
      'Transfer-Encoding', 'chunked'
    }
  });
});

export default app;
```

##### Í≥†Í∏â Writer Í∏∞Îä•

```typescript
import { StaxXmlWriter } from 'stax-xml';

// ÏÇ¨Ïö©Ïûê Ï†ïÏùò ÏóîÌã∞Ìã∞ÏôÄ ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§Î•º ÏÇ¨Ïö©Ìïú Î©îÎ™®Î¶¨ ÎÇ¥ XML ÏÉùÏÑ±
async function createAdvancedXml() {
  let xmlOutput = '';
  
  const writableStream = new WritableStream<Uint8Array>({
    write(chunk) {
      xmlOutput += new TextDecoder().decode(chunk);
    }
  });

  const writer = new StaxXmlWriter(writableStream, {
    prettyPrint: true,
    indentString: '  ',
    addEntities: [
      { entity: 'company', value: 'ÏïÑÌÅ¨Î©î ÏΩîÌçºÎ†àÏù¥ÏÖò' },
      { entity: 'copyright', value: '¬© 2024' }
    ],
    autoEncodeEntities: true
  });

  // ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ÏôÄ ÏÇ¨Ïö©Ïûê Ï†ïÏùò ÏóîÌã∞Ìã∞Í∞Ä Ìè¨Ìï®Îêú XML ÏûëÏÑ±
  await writer.writeStartDocument('1.0', 'utf-8');
  
  await writer.writeStartElement('document', { 
    prefix: 'doc', 
    uri: 'http://example.com/document', 
    attributes: { version: '2.0' } 
  });
  await writer.writeNamespace('meta', 'http://example.com/metadata');
  
  await writer.writeStartElement('header', { prefix: 'meta' });
  await writer.writeStartElement('title');
  await writer.writeCharacters('Ï†úÌíà Ïπ¥ÌÉàÎ°úÍ∑∏');
  await writer.writeEndElement();
  
  await writer.writeStartElement('company');
  await writer.writeCharacters('&company;'); // ÏûêÎèôÏúºÎ°ú Ïù∏ÏΩîÎî©Îê©ÎãàÎã§
  await writer.writeEndElement();
  await writer.writeEndElement(); // header
  
  await writer.writeStartElement('content');
  await writer.writeStartElement('item', { attributes: { type: 'featured' } });
  
  // Self-closing ÏöîÏÜå
  await writer.writeStartElement('thumbnail', {
    attributes: {
      src: 'image.jpg',
      alt: 'Ï†úÌíà Ïù¥ÎØ∏ÏßÄ'
    },
    selfClosing: true
  });
  
  await writer.writeStartElement('description');
  await writer.writeCDATA('<p>Ïù¥Í≤ÉÏùÄ CDATA ÎÇ¥Ïùò <b>HTML</b> ÏΩòÌÖêÏ∏†ÏûÖÎãàÎã§</p>');
  await writer.writeEndElement();
  
  await writer.writeEndElement(); // item
  await writer.writeEndElement(); // content
  await writer.writeEndElement(); // document
  
  await writer.writeEndDocument();
  
  return xmlOutput;
}

// ÏÇ¨Ïö©Î≤ï
createAdvancedXml().then(xml => {
  console.log('ÏÉùÏÑ±Îêú XML:', xml);
});
```

##### ÏÉàÎ°úÏö¥ ÌÜµÌï© WriteElementOptions API

StaxXmlWriterÎäî Ïù¥Ï†ú Î™®Îì† ÏòµÏÖòÏùÑ Îã®Ïùº `WriteElementOptions` Í∞ùÏ≤¥Î°ú ÌÜµÌï©ÌïòÏó¨ ÏöîÏÜå ÏÉùÏÑ±ÏùÑ Îã®ÏàúÌôîÌïòÎäî ÏÉàÎ°úÏö¥ ÌÜµÌï© APIÎ•º ÏßÄÏõêÌï©ÎãàÎã§:

```typescript
import { StaxXmlWriter, WriteElementOptions } from 'stax-xml';

async function createXmlWithNewAPI() {
  let xmlOutput = '';
  
  const writableStream = new WritableStream<Uint8Array>({
    write(chunk) {
      xmlOutput += new TextDecoder().decode(chunk);
    }
  });

  const writer = new StaxXmlWriter(writableStream, { prettyPrint: true });

  await writer.writeStartDocument();
  
  // ÏÜçÏÑ±Ïù¥ ÏûàÎäî Í∏∞Î≥∏ ÏöîÏÜå
  await writer.writeStartElement('catalog', {
    attributes: { version: '2.0', xmlns: 'http://example.com/catalog' }
  });
  
  // ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ÏôÄ ÏÜçÏÑ±Ïù¥ ÏûàÎäî ÏöîÏÜå
  await writer.writeStartElement('product', {
    prefix: 'cat',
    uri: 'http://example.com/catalog',
    attributes: { id: '001', featured: 'true' }
  });
  
  await writer.writeStartElement('name');
  await writer.writeCharacters('ÌîÑÎ¶¨ÎØ∏ÏóÑ ÎÖ∏Ìä∏Î∂Å');
  await writer.writeEndElement();
  
  // ÏÜçÏÑ±Ïù¥ ÏûàÎäî self-closing ÏöîÏÜå
  await writer.writeStartElement('thumbnail', {
    attributes: {
      src: 'image.jpg',
      alt: 'Ï†úÌíà Ïù¥ÎØ∏ÏßÄ',
      width: '200'
    },
    selfClosing: true  // writeEndElement() Ìò∏Ï∂ú Î∂àÌïÑÏöî
  });
  
  // Í∞ÑÎã®Ìïú self-closing ÏöîÏÜå
  await writer.writeStartElement('br', { selfClosing: true });
  
  await writer.writeEndElement(); // product
  await writer.writeEndElement(); // catalog
  
  await writer.writeEndDocument();
  return xmlOutput;
}

// Ï∂úÎ†•:
// <?xml version="1.0" encoding="UTF-8"?>
// <catalog version="2.0" xmlns="http://example.com/catalog">
//   <cat:product id="001" featured="true" xmlns:cat="http://example.com/catalog">
//     <name>ÌîÑÎ¶¨ÎØ∏ÏóÑ ÎÖ∏Ìä∏Î∂Å</name>
//     <thumbnail src="image.jpg" alt="Ï†úÌíà Ïù¥ÎØ∏ÏßÄ" width="200"/>
//     <br/>
//   </cat:product>
// </catalog>
```

**ÏÉàÎ°úÏö¥ APIÏùò Ï£ºÏöî Ïû•Ï†ê:**

- **ÌÜµÌï©Îêú ÌååÎùºÎØ∏ÌÑ∞**: Î™®Îì† ÏöîÏÜå ÏòµÏÖò(ÏÜçÏÑ±, ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§, self-closing)Ïù¥ Îã®Ïùº ÏòµÏÖò Í∞ùÏ≤¥Î°ú ÌÜµÌï©
- **Self-Closing ÏßÄÏõê**: `selfClosing: true`Î°ú ÏÑ§Ï†ïÌïòÎ©¥ `writeEndElement()` Ìò∏Ï∂ú ÏóÜÏù¥ ÏûêÎèôÏúºÎ°ú ÏöîÏÜåÍ∞Ä Îã´Ìûò
- **Îçî ÍπîÎÅîÌïú Î¨∏Î≤ï**: Îçî ÏßÅÍ¥ÄÏ†ÅÏù¥Í≥† ÏùΩÍ∏∞ Ïâ¨Ïö¥ ÏΩîÎìú Íµ¨Ï°∞
- **ÌÉÄÏûÖ ÏïàÏ†ÑÏÑ±**: Ìè¨Í¥ÑÏ†ÅÏù∏ ÌÉÄÏûÖ Ï†ïÏùòÎ°ú ÏôÑÏ†ÑÌïú TypeScript ÏßÄÏõê

**ÏÇ¨Ïö© ÏòàÏ†ú:**

```typescript
// ÏÜçÏÑ±Ïù¥ ÏûàÎäî Í∞ÑÎã®Ìïú ÏöîÏÜå
await writer.writeStartElement('img', {
  attributes: {
    src: 'image.jpg',
    alt: 'Ïù¥ÎØ∏ÏßÄ'
  },
  selfClosing: true
});

// ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§Í∞Ä ÏûàÎäî ÏöîÏÜå
await writer.writeStartElement('title', {
  prefix: 'html',
  uri: 'http://www.w3.org/1999/xhtml',
  attributes: { lang: 'ko' }
});
```

#### Custom Entity Support

```typescript
const parser = new StaxXmlParser(stream, {
  addEntities: [
    { entity: 'custom', value: 'ÏÇ¨Ïö©Ïûê Ï†ïÏùò Í∞í' },
    { entity: 'special', value: '‚òÖ' }
  ]
});
```

#### Large File Processing

```typescript
// ÎåÄÏö©Îüâ XML ÌååÏùºÏùò Ìö®Ïú®Ï†Å Ï≤òÎ¶¨
const parser = new StaxXmlParser(largeXmlStream, {
  maxBufferSize: 128 * 1024, // 128KB Î≤ÑÌçº
  enableBufferCompaction: true
});

// Ï†ÑÏ≤¥ ÌååÏùºÏùÑ Î©îÎ™®Î¶¨Ïóê Î°úÎìúÌïòÏßÄ ÏïäÍ≥† Ïù¥Î≤§Ìä∏Î•º ÏàúÏ∞®Ï†ÅÏúºÎ°ú Ï≤òÎ¶¨
for await (const event of parser) {
  // Í∞Å Ïù¥Î≤§Ìä∏Î•º Í∞úÎ≥ÑÏ†ÅÏúºÎ°ú Ï≤òÎ¶¨
  processEvent(event);
}
```

#### Namespace Handling

```typescript
// ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§Í∞Ä ÏûàÎäî XML
const xmlWithNamespaces = `
  <root xmlns:ns="http://example.com/namespace">
    <ns:element>ÎÇ¥Ïö©</ns:element>
  </root>
`;

for await (const event of parser) {
  if (event.type === XmlEventType.START_ELEMENT) {
    console.log('ÏöîÏÜåÎ™Ö:', event.name);
    console.log('Î°úÏª¨Î™Ö:', event.localName);
    console.log('ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ URI:', event.uri);
    console.log('Ï†ëÎëêÏÇ¨:', event.prefix);
  }
}
```

### üéØ Event Types

- `START_DOCUMENT`: XML Î¨∏ÏÑú ÏãúÏûë
- `END_DOCUMENT`: XML Î¨∏ÏÑú ÎÅù
- `START_ELEMENT`: XML ÏãúÏûë ÌÉúÍ∑∏
- `END_ELEMENT`: XML ÎÅù ÌÉúÍ∑∏
- `CHARACTERS`: ÌÉúÍ∑∏ ÏÇ¨Ïù¥Ïùò ÌÖçÏä§Ìä∏ ÎÇ¥Ïö©
- `CDATA`: CDATA ÏÑπÏÖò ÎÇ¥Ïö©
- `ERROR`: ÌååÏã± Ïò§Î•ò Î∞úÏÉù

### üìö API Reference

#### StaxXmlParser

```typescript
class StaxXmlParser {
  constructor(
    xmlStream: ReadableStream<Uint8Array>,
    options?: StaxXmlParserOptions
  )
}

interface StaxXmlParserOptions {
  encoding?: string; // Í∏∞Î≥∏Í∞í: 'utf-8'
  addEntities?: { entity: string, value: string }[];
  autoDecodeEntities?: boolean; // Í∏∞Î≥∏Í∞í: true
  maxBufferSize?: number; // Í∏∞Î≥∏Í∞í: 64KB
  enableBufferCompaction?: boolean; // Í∏∞Î≥∏Í∞í: true
}
```

#### StaxXmlParserSync

```typescript
class StaxXmlParserSync {
  constructor(
    xmlString: string,
    options?: StaxXmlParserSyncOptions
  )
}

interface StaxXmlParserSyncOptions {
  autoDecodeEntities?: boolean; // Í∏∞Î≥∏Í∞í: true
  addEntities?: { entity: string, value: string }[];
}
```

#### StaxXmlWriter

```typescript
interface WriteElementOptions {
  prefix?: string;              // ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ Ï†ëÎëêÏÇ¨
  uri?: string;                 // ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ URI
  attributes?: Record<string, string>; // ÏöîÏÜå ÏÜçÏÑ±
  selfClosing?: boolean;        // self-closing ÌÉúÍ∑∏ Ïó¨Î∂Ä
}

class StaxXmlWriter {
  constructor(
    outputStream: WritableStream<Uint8Array>,
    options?: StaxXmlWriterOptions
  )

  // Î¨∏ÏÑú Î†àÎ≤® Î©îÏÑúÎìú
  writeStartDocument(version?: string, encoding?: string): this
  writeEndDocument(): Promise<void>

  // ÏöîÏÜå ÏûëÏÑ± Î©îÏÑúÎìú
  writeStartElement(localName: string, options?: WriteElementOptions): this
  writeEndElement(): this

  // ÏÜçÏÑ± Î∞è ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ Î©îÏÑúÎìú
  writeAttribute(localName: string, value: string, prefix?: string, uri?: string): this
  writeNamespace(prefix: string, uri: string): this

  // ÏΩòÌÖêÏ∏† ÏûëÏÑ± Î©îÏÑúÎìú
  writeCharacters(text: string): this
  writeCDATA(cdata: string): this
  writeComment(comment: string): this
  writeProcessingInstruction(target: string, data?: string): this

  // Ïú†Ìã∏Î¶¨Ìã∞ Î©îÏÑúÎìú
  setPrettyPrint(enabled: boolean): this
  setIndentString(indentString: string): this
  isPrettyPrintEnabled(): boolean
  getIndentString(): string
}

interface StaxXmlWriterOptions {
  encoding?: string; // Í∏∞Î≥∏Í∞í: 'utf-8'
  prettyPrint?: boolean; // Í∏∞Î≥∏Í∞í: false
  indentString?: string; // Í∏∞Î≥∏Í∞í: '  '
  addEntities?: { entity: string, value: string }[];
  autoEncodeEntities?: boolean; // Í∏∞Î≥∏Í∞í: true
  namespaces?: NamespaceDeclaration[];
}

interface XmlAttribute {
  localName: string;
  value: string;
  prefix?: string;
  uri?: string;
}

interface NamespaceDeclaration {
  prefix?: string;
  uri: string;
}
```

### üß™ ÌÖåÏä§Ìä∏

```bash
bun test
```

### üìÅ ÏÉòÌîå ÌååÏùº Ï∂úÏ≤ò

ÌÖåÏä§Ìä∏Ïóê ÏÇ¨Ïö©Îêú ÏÉòÌîå XML ÌååÏùºÎì§Ïùò Ï∂úÏ≤ò:

- `books.xml`: [Microsoft XML Î¨∏ÏÑú ÏòàÏ†ú](https://learn.microsoft.com/en-us/previous-versions/windows/desktop/ms762271(v=vs.85))
- `simple-namespace.xml`: [W3Schools XML ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ Í∞ÄÏù¥Îìú](https://www.w3schools.com/xml/xml_namespaces.asp)
- `treebank_e.xml`: [University of Washington XML Data Repository](https://aiweb.cs.washington.edu/research/projects/xmltk/xmldata/www/repository.html)

### üìÑ ÎùºÏù¥ÏÑ†Ïä§

MIT

### ü§ù Í∏∞Ïó¨ÌïòÍ∏∞

Í∏∞Ïó¨Î•º ÌôòÏòÅÌï©ÎãàÎã§! Pull RequestÎ•º ÏûêÏú†Î°≠Í≤å Ï†úÏ∂úÌï¥ Ï£ºÏÑ∏Ïöî.